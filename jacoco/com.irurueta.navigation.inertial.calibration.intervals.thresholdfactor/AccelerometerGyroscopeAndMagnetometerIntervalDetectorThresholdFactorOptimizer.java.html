<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial-extra</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.intervals.thresholdfactor</a> &gt; <span class="el_source">AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizer.java</span></div><h1>AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2021 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.intervals.thresholdfactor;

import com.irurueta.algebra.Matrix;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.inertial.INSLooselyCoupledKalmanInitializerConfig;
import com.irurueta.navigation.inertial.INSTightlyCoupledKalmanInitializerConfig;
import com.irurueta.navigation.inertial.calibration.AccelerometerNoiseRootPsdSource;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence;
import com.irurueta.navigation.inertial.calibration.CalibrationException;
import com.irurueta.navigation.inertial.calibration.GyroscopeNoiseRootPsdSource;
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyKinematics;
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyMagneticFluxDensity;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematicsAndMagneticFluxDensity;
import com.irurueta.navigation.inertial.calibration.accelerometer.AccelerometerCalibratorMeasurementType;
import com.irurueta.navigation.inertial.calibration.accelerometer.AccelerometerNonLinearCalibrator;
import com.irurueta.navigation.inertial.calibration.accelerometer.KnownBiasAccelerometerCalibrator;
import com.irurueta.navigation.inertial.calibration.accelerometer.OrderedStandardDeviationBodyKinematicsAccelerometerCalibrator;
import com.irurueta.navigation.inertial.calibration.accelerometer.QualityScoredAccelerometerCalibrator;
import com.irurueta.navigation.inertial.calibration.accelerometer.UnknownBiasAccelerometerCalibrator;
import com.irurueta.navigation.inertial.calibration.accelerometer.UnorderedStandardDeviationBodyKinematicsAccelerometerCalibrator;
import com.irurueta.navigation.inertial.calibration.generators.AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator;
import com.irurueta.navigation.inertial.calibration.generators.AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener;
import com.irurueta.navigation.inertial.calibration.gyroscope.AccelerometerDependentGyroscopeCalibrator;
import com.irurueta.navigation.inertial.calibration.gyroscope.GyroscopeCalibratorMeasurementOrSequenceType;
import com.irurueta.navigation.inertial.calibration.gyroscope.GyroscopeNonLinearCalibrator;
import com.irurueta.navigation.inertial.calibration.gyroscope.OrderedBodyKinematicsSequenceGyroscopeCalibrator;
import com.irurueta.navigation.inertial.calibration.gyroscope.QualityScoredGyroscopeCalibrator;
import com.irurueta.navigation.inertial.calibration.gyroscope.UnknownBiasGyroscopeCalibrator;
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector;
import com.irurueta.navigation.inertial.calibration.magnetometer.KnownHardIronMagnetometerCalibrator;
import com.irurueta.navigation.inertial.calibration.magnetometer.MagnetometerCalibratorMeasurementType;
import com.irurueta.navigation.inertial.calibration.magnetometer.MagnetometerNonLinearCalibrator;
import com.irurueta.navigation.inertial.calibration.magnetometer.OrderedStandardDeviationBodyMagneticFluxDensityMagnetometerCalibrator;
import com.irurueta.navigation.inertial.calibration.magnetometer.QualityScoredMagnetometerCalibrator;
import com.irurueta.navigation.inertial.calibration.magnetometer.UnknownHardIronMagnetometerCalibrator;
import com.irurueta.navigation.inertial.calibration.magnetometer.UnorderedStandardDeviationBodyMagneticFluxDensityMagnetometerCalibrator;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.Time;

import java.util.ArrayList;
import java.util.List;

/**
 * Optimizes the threshold factor for interval detection of accelerometer and gyroscope
 * data based on results of calibration.
 * Implementations of this class will attempt to find the best threshold factor
 * between the provided range of values.
 * Only accelerometer calibrators based on unknown orientation are supported (in other terms,
 * calibrators must be {@link AccelerometerNonLinearCalibrator} and must support
 * {@link AccelerometerCalibratorMeasurementType#STANDARD_DEVIATION_BODY_KINEMATICS}).
 * Only gyroscope calibrators based on unknown orientation are supported (in other terms,
 * calibrators must be {@link GyroscopeNonLinearCalibrator} and must support
 * {@link GyroscopeCalibratorMeasurementOrSequenceType#BODY_KINEMATICS_SEQUENCE}).
 * Only magnetometer calibrators based on unknown orientation are supported, in other terms,
 * calibrators must be {@link MagnetometerNonLinearCalibrator} and must support
 * {@link MagnetometerCalibratorMeasurementType#STANDARD_DEVIATION_BODY_MAGNETIC_FLUX_DENSITY}.
 */
public abstract class AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizer extends
        IntervalDetectorThresholdFactorOptimizer&lt;TimedBodyKinematicsAndMagneticFluxDensity,
                AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizerDataSource&gt; implements
        AccelerometerNoiseRootPsdSource, GyroscopeNoiseRootPsdSource {

    /**
     * Default minimum threshold factor.
     */
    public static final double DEFAULT_MIN_THRESHOLD_FACTOR = 2.0;

    /**
     * Default maximum threshold factor.
     */
    public static final double DEFAULT_MAX_THRESHOLD_FACTOR = 10.0;

    /**
     * Minimum threshold factor.
     */
<span class="fc" id="L94">    protected double minThresholdFactor = DEFAULT_MIN_THRESHOLD_FACTOR;</span>

    /**
     * Maximum threshold factor.
     */
<span class="fc" id="L99">    protected double maxThresholdFactor = DEFAULT_MAX_THRESHOLD_FACTOR;</span>

    /**
     * Accelerometer calibrator.
     */
    private AccelerometerNonLinearCalibrator accelerometerCalibrator;

    /**
     * Gyroscope calibrator.
     */
    private GyroscopeNonLinearCalibrator gyroscopeCalibrator;

    /**
     * Magnetometer calibrator.
     */
    private MagnetometerNonLinearCalibrator magnetometerCalibrator;

    /**
     * A measurement generator for accelerometer, gyroscope and magnetometer calibrators.
     */
    private AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator;

    /**
     * Generated measurements to be used for accelerometer calibration.
     */
    private List&lt;StandardDeviationBodyKinematics&gt; accelerometerMeasurements;

    /**
     * Generated sequences to be used for gyroscope calibration.
     */
    private List&lt;BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt;&gt; gyroscopeSequences;

    /**
     * Generated measurements to be used for magnetometer calibration.
     */
    private List&lt;StandardDeviationBodyMagneticFluxDensity&gt; magnetometerMeasurements;

    /**
     * Mapper to convert {@link StandardDeviationBodyKinematics} measurements into
     * quality scores.
     */
<span class="fc" id="L140">    private QualityScoreMapper&lt;StandardDeviationBodyKinematics&gt; accelerometerQualityScoreMapper =</span>
            new DefaultAccelerometerQualityScoreMapper();

    /**
     * Mapper to convert {@link BodyKinematicsSequence} sequences of {@link StandardDeviationTimedBodyKinematics}
     * into quality scores.
     */
<span class="fc" id="L147">    private QualityScoreMapper&lt;BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt;&gt;</span>
            gyroscopeQualityScoreMapper = new DefaultGyroscopeQualityScoreMapper();

    /**
     * Mapper to convert {@link StandardDeviationBodyMagneticFluxDensity} measurements
     * into quality scores.
     */
<span class="fc" id="L154">    private QualityScoreMapper&lt;StandardDeviationBodyMagneticFluxDensity&gt; magnetometerQualityScoreMapper =</span>
            new DefaultMagnetometerQualityScoreMapper();

    /**
     * Rule to convert accelerometer, gyroscope and magnetometer MSE
     * values into a single global MSE value.
     */
<span class="fc" id="L161">    private AccelerometerGyroscopeAndMagnetometerMseRule mseRule =</span>
            new DefaultAccelerometerGyroscopeAndMagnetometerMseRule();

    /**
     * Estimated norm of gyroscope noise root PSD (Power Spectral Density)
     * expressed as (rad * s^-0.5).
     */
    private double angularSpeedNoiseRootPsd;

    /**
     * Accelerometer base noise level that has been detected during
     * initialization of the best solution that has been found expressed in
     * meters per squared second (m/s^2).
     * This is equal to the standard deviation of the accelerometer measurements
     * during the initialization phase.
     */
    private double baseNoiseLevel;

    /**
     * Threshold to determine static/dynamic period changes expressed in
     * meters per squared second (m/s^2) for the best calibration solution that
     * has been found.
     */
    private double threshold;

    /**
     * Estimated covariance matrix for estimated accelerometer parameters.
     */
    private Matrix estimatedAccelerometerCovariance;

    /**
     * Estimated accelerometer scale factors and cross-coupling errors.
     * This is the product of matrix Ta containing cross-coupling errors and Ka
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix. However, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     */
    private Matrix estimatedAccelerometerMa;

    /**
     * Estimated accelerometer biases for each IMU axis expressed in meter per squared
     * second (m/s^2).
     */
    private double[] estimatedAccelerometerBiases;

    /**
     * Estimated covariance matrix for estimated gyroscope parameters.
     */
    private Matrix estimatedGyroscopeCovariance;

    /**
     * Estimated angular rate biases for each IMU axis expressed in radians per
     * second (rad/s).
     */
    private double[] estimatedGyroscopeBiases;

    /**
     * Estimated gyroscope scale factors and cross-coupling errors.
     * This is the product of matrix Tg containing cross-coupling errors and Kg
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix. However, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the gyroscope z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Mg matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     */
    private Matrix estimatedGyroscopeMg;

    /**
     * Estimated G-dependent cross-biases introduced on the gyroscope by the
     * specific forces sensed by the accelerometer.
     * This instance allows any 3x3 matrix.
     */
    private Matrix estimatedGyroscopeGg;

    /**
     * Estimated covariance matrix for estimated magnetometer parameters.
     */
    private Matrix estimatedMagnetometerCovariance;

    /**
     * Estimated magnetometer soft-iron matrix containing scale factors
     * and cross-coupling errors.
     * This is the product of matrix Tm containing cross-coupling errors and Km
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Mm = [sx    mxy  mxz] = Tm*Km
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Km = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tm = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mm = [sx    mxy  mxz] = Tm*Km =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix. However, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Mm matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Mm = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     */
    private Matrix estimatedMagnetometerMm;

    /**
     * Estimated magnetometer hard-iron biases for each magnetometer axis
     * expressed in Teslas (T).
     */
    private double[] estimatedMagnetometerHardIron;

    /**
     * Constructor.
     */
<span class="fc" id="L353">    protected AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizer() {</span>
<span class="fc" id="L354">        initialize();</span>
<span class="fc" id="L355">    }</span>

    /**
     * Constructor.
     *
     * @param dataSource instance in charge of retrieving data for this optimizer.
     */
    protected AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizer(
            final AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizerDataSource dataSource) {
<span class="fc" id="L364">        super(dataSource);</span>
<span class="fc" id="L365">        initialize();</span>
<span class="fc" id="L366">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerCalibrator an accelerometer calibrator to be used to
     *                                optimize its Mean Square Error (MSE).
     * @param gyroscopeCalibrator     a gyroscope calibrator to be used to optimize
     *                                its Mean Square Error (MSE).
     * @param magnetometerCalibrator  a magnetometer calibrator to be used to
     *                                optimize its Mean Square Error (MSE).
     * @throws IllegalArgumentException if accelerometer calibrator does not use
     *                                  {@link StandardDeviationBodyKinematics} measurements,
     *                                  if gyroscope calibrator does not use
     *                                  {@link BodyKinematicsSequence} sequences of
     *                                  {@link StandardDeviationTimedBodyKinematics} or
     *                                  if magnetometer calibrator does not use
     *                                  {@link StandardDeviationBodyMagneticFluxDensity} measurements.
     */
    protected AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizer(
            final AccelerometerNonLinearCalibrator accelerometerCalibrator,
            final GyroscopeNonLinearCalibrator gyroscopeCalibrator,
<span class="fc" id="L388">            final MagnetometerNonLinearCalibrator magnetometerCalibrator) {</span>
        try {
<span class="fc" id="L390">            setAccelerometerCalibrator(accelerometerCalibrator);</span>
<span class="fc" id="L391">            setGyroscopeCalibrator(gyroscopeCalibrator);</span>
<span class="fc" id="L392">            setMagnetometerCalibrator(magnetometerCalibrator);</span>
<span class="nc" id="L393">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L395">        }</span>
<span class="fc" id="L396">        initialize();</span>
<span class="fc" id="L397">    }</span>

    /**
     * Constructor.
     *
     * @param dataSource              instance in charge of retrieving data for this optimizer.
     * @param accelerometerCalibrator an accelerometer calibrator to be used to
     *                                optimize its Mean Square Error (MSE).
     * @param gyroscopeCalibrator     a gyroscope calibrator to be used to optimize
     *                                its Mean Square Error (MSE).
     * @param magnetometerCalibrator  a magnetometer calibrator to be used to
     *                                optimize its Mean Square Error (MSE).
     * @throws IllegalArgumentException if accelerometer calibrator does not use
     *                                  {@link StandardDeviationBodyKinematics} measurements,
     *                                  if gyroscope calibrator does not use
     *                                  {@link BodyKinematicsSequence} sequences of
     *                                  {@link StandardDeviationTimedBodyKinematics} or
     *                                  if magnetometer calibrator does not use
     *                                  {@link StandardDeviationBodyMagneticFluxDensity} measurements.
     */
    protected AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizer(
            final AccelerometerGyroscopeAndMagnetometerIntervalDetectorThresholdFactorOptimizerDataSource dataSource,
            final AccelerometerNonLinearCalibrator accelerometerCalibrator,
            final GyroscopeNonLinearCalibrator gyroscopeCalibrator,
            final MagnetometerNonLinearCalibrator magnetometerCalibrator) {
<span class="fc" id="L422">        super(dataSource);</span>
        try {
<span class="fc" id="L424">            setAccelerometerCalibrator(accelerometerCalibrator);</span>
<span class="fc" id="L425">            setGyroscopeCalibrator(gyroscopeCalibrator);</span>
<span class="fc" id="L426">            setMagnetometerCalibrator(magnetometerCalibrator);</span>
<span class="nc" id="L427">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L429">        }</span>
<span class="fc" id="L430">        initialize();</span>
<span class="fc" id="L431">    }</span>

    /**
     * Gets provided accelerometer calibrator to be used to optimize its Mean Square Error (MSE).
     *
     * @return accelerometer calibrator to be used to optimize its MSE.
     */
    public AccelerometerNonLinearCalibrator getAccelerometerCalibrator() {
<span class="fc" id="L439">        return accelerometerCalibrator;</span>
    }

    /**
     * Sets accelerometer calibrator to be used to optimize its Mean Square Error (MSE).
     *
     * @param accelerometerCalibrator accelerometer calibrator to be used to optimize its MSE.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if accelerometer calibrator does not use
     *                                  {@link StandardDeviationBodyKinematics} measurements.
     */
    public void setAccelerometerCalibrator(
            final AccelerometerNonLinearCalibrator accelerometerCalibrator) throws LockedException {
<span class="fc bfc" id="L452" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L453">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L456" title="1 of 4 branches missed.">        if (accelerometerCalibrator != null &amp;&amp; accelerometerCalibrator.getMeasurementType()</span>
                != AccelerometerCalibratorMeasurementType.STANDARD_DEVIATION_BODY_KINEMATICS) {
<span class="fc" id="L458">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L461">        this.accelerometerCalibrator = accelerometerCalibrator;</span>
<span class="fc" id="L462">    }</span>

    /**
     * Gets provided gyroscope calibrator to be used to optimize its Mean Square Error (MSE).
     *
     * @return gyroscope calibrator to be used to optimize its MSE.
     */
    public GyroscopeNonLinearCalibrator getGyroscopeCalibrator() {
<span class="fc" id="L470">        return gyroscopeCalibrator;</span>
    }

    /**
     * Sets gyroscope calibrator to be used to optimize its Mean Square Error (MSE).
     *
     * @param gyroscopeCalibrator gyroscope calibrator to be use dto optimize its MSE.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if gyroscope calibrator does not use
     *                                  {@link BodyKinematicsSequence} sequences of
     *                                  {@link StandardDeviationTimedBodyKinematics}.
     */
    public void setGyroscopeCalibrator(final GyroscopeNonLinearCalibrator gyroscopeCalibrator) throws LockedException {
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L484">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L487" title="1 of 4 branches missed.">        if (gyroscopeCalibrator != null &amp;&amp; gyroscopeCalibrator.getMeasurementOrSequenceType()</span>
                != GyroscopeCalibratorMeasurementOrSequenceType.BODY_KINEMATICS_SEQUENCE) {
<span class="fc" id="L489">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L492">        this.gyroscopeCalibrator = gyroscopeCalibrator;</span>
<span class="fc" id="L493">    }</span>

    /**
     * Gets provided magnetometer calibrator to be used to optimize its Mean Square Error (MSE).
     *
     * @return magnetometer calibrator to be used to optimize its MSE.
     */
    public MagnetometerNonLinearCalibrator getMagnetometerCalibrator() {
<span class="fc" id="L501">        return magnetometerCalibrator;</span>
    }

    /**
     * Sets a magnetometer calibrator to be used to optimize its Mean Square Error.
     *
     * @param magnetometerCalibrator magnetometer calibrator to be used to optimize its MSE.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if magnetometer calibrator does not use
     *                                  {@link StandardDeviationBodyMagneticFluxDensity} measurements.
     */
    public void setMagnetometerCalibrator(final MagnetometerNonLinearCalibrator magnetometerCalibrator)
            throws LockedException {
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        if (running) {</span>
<span class="nc" id="L515">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L518" title="1 of 4 branches missed.">        if (magnetometerCalibrator != null &amp;&amp; magnetometerCalibrator.getMeasurementType()</span>
                != MagnetometerCalibratorMeasurementType.STANDARD_DEVIATION_BODY_MAGNETIC_FLUX_DENSITY) {
<span class="fc" id="L520">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L523">        this.magnetometerCalibrator = magnetometerCalibrator;</span>
<span class="fc" id="L524">    }</span>

    /**
     * Gets mapper to convert {@link StandardDeviationBodyKinematics} accelerometer measurements
     * into quality scores.
     *
     * @return mapper to convert accelerometer measurements into quality scores.
     */
    public QualityScoreMapper&lt;StandardDeviationBodyKinematics&gt; getAccelerometerQualityScoreMapper() {
<span class="fc" id="L533">        return accelerometerQualityScoreMapper;</span>
    }

    /**
     * Sets mapper to convert {@link StandardDeviationBodyKinematics} accelerometer measurements
     * into quality scores.
     *
     * @param accelerometerQualityScoreMapper mapper to convert accelerometer measurements into
     *                                        quality scores.
     * @throws LockedException if optimizer is already running.
     */
    public void setAccelerometerQualityScoreMapper(
            final QualityScoreMapper&lt;StandardDeviationBodyKinematics&gt; accelerometerQualityScoreMapper)
            throws LockedException {
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L548">            throw new LockedException();</span>
        }

<span class="fc" id="L551">        this.accelerometerQualityScoreMapper = accelerometerQualityScoreMapper;</span>
<span class="fc" id="L552">    }</span>

    /**
     * Gets mapper to convert {@link BodyKinematicsSequence} gyroscope sequences of
     * {@link StandardDeviationTimedBodyKinematics} into quality scores.
     *
     * @return mapper to convert gyroscope sequences into quality scores.
     */
    public QualityScoreMapper&lt;BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt;&gt;
    getGyroscopeQualityScoreMapper() {
<span class="fc" id="L562">        return gyroscopeQualityScoreMapper;</span>
    }

    /**
     * Sets mapper to convert {@link BodyKinematicsSequence} gyroscope sequences of
     * {@link StandardDeviationTimedBodyKinematics} into quality scores.
     *
     * @param gyroscopeQualityScoreMapper mapper to convert gyroscope sequences
     *                                    into quality scores.
     * @throws LockedException if optimizer is already running.
     */
    public void setGyroscopeQualityScoreMapper(
            final QualityScoreMapper&lt;BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt;&gt;
                    gyroscopeQualityScoreMapper) throws LockedException {
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L577">            throw new LockedException();</span>
        }

<span class="fc" id="L580">        this.gyroscopeQualityScoreMapper = gyroscopeQualityScoreMapper;</span>
<span class="fc" id="L581">    }</span>

    /**
     * Gets mapper to convert {@link StandardDeviationBodyMagneticFluxDensity} magnetometer
     * measurements into quality scores.
     *
     * @return mapper to convert magnetometer measurements into quality scores.
     */
    public QualityScoreMapper&lt;StandardDeviationBodyMagneticFluxDensity&gt; getMagnetometerQualityScoreMapper() {
<span class="fc" id="L590">        return magnetometerQualityScoreMapper;</span>
    }

    /**
     * Sets mapper to convert {@link StandardDeviationBodyMagneticFluxDensity} magnetometer
     * measurements into quality scores.
     *
     * @param magnetometerQualityScoreMapper mapper to convert magnetometer measurements into
     *                                       quality scores.
     * @throws LockedException if optimizer is already running.
     */
    public void setMagnetometerQualityScoreMapper(
            final QualityScoreMapper&lt;StandardDeviationBodyMagneticFluxDensity&gt; magnetometerQualityScoreMapper)
            throws LockedException {
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        if (running) {</span>
<span class="nc" id="L605">            throw new LockedException();</span>
        }

<span class="fc" id="L608">        this.magnetometerQualityScoreMapper = magnetometerQualityScoreMapper;</span>
<span class="fc" id="L609">    }</span>

    /**
     * Gets rule to convert accelerometer, gyroscope and magnetometer
     * MSE values into a single global MSE value.
     *
     * @return rule to convert accelerometer, gyroscope and
     * magnetometer MSE values into a single global MSE value.
     */
    public AccelerometerGyroscopeAndMagnetometerMseRule getMseRule() {
<span class="fc" id="L619">        return mseRule;</span>
    }

    /**
     * Sets rule to convert accelerometer, gyroscope and magnetometer
     * MSE values into a single global MSE value.
     *
     * @param mseRule rule to convert accelerometer, gyroscope and
     *                magnetometer MSE values into a single global
     *                MSE value.
     * @throws LockedException if optimizer is already running.
     */
    public void setMseRule(final AccelerometerGyroscopeAndMagnetometerMseRule mseRule) throws LockedException {
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        if (running) {</span>
<span class="nc" id="L633">            throw new LockedException();</span>
        }

<span class="fc" id="L636">        this.mseRule = mseRule;</span>
<span class="fc" id="L637">    }</span>

    /**
     * Gets the minimum threshold factor.
     *
     * @return minimum threshold factor.
     */
    public double getMinThresholdFactor() {
<span class="fc" id="L645">        return minThresholdFactor;</span>
    }

    /**
     * Gets the maximum threshold factor.
     *
     * @return maximum threshold factor.
     */
    public double getMaxThresholdFactor() {
<span class="fc" id="L654">        return maxThresholdFactor;</span>
    }

    /**
     * Sets a range of threshold factor values to get an optimized
     * threshold factor value.
     *
     * @param minThresholdFactor minimum threshold.
     * @param maxThresholdFactor maximum threshold.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if either minimum or maximum values are
     *                                  negative, or if the minimum value is larger
     *                                  than the maximum one.
     */
    public void setThresholdFactorRange(final double minThresholdFactor, final double maxThresholdFactor)
            throws LockedException {
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L671">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L673" title="All 6 branches covered.">        if (minThresholdFactor &lt; 0.0 || maxThresholdFactor &lt; 0.0 || minThresholdFactor &gt;= maxThresholdFactor) {</span>
<span class="fc" id="L674">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L677">        this.minThresholdFactor = minThresholdFactor;</span>
<span class="fc" id="L678">        this.maxThresholdFactor = maxThresholdFactor;</span>
<span class="fc" id="L679">    }</span>

    /**
     * Indicates whether this optimizer is ready to start optimization.
     *
     * @return true if this optimizer is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L688" title="1 of 16 branches missed.">        return super.isReady() &amp;&amp; accelerometerCalibrator != null</span>
                &amp;&amp; gyroscopeCalibrator != null
                &amp;&amp; magnetometerCalibrator != null
                &amp;&amp; accelerometerQualityScoreMapper != null
                &amp;&amp; gyroscopeQualityScoreMapper != null
                &amp;&amp; magnetometerQualityScoreMapper != null
                &amp;&amp; mseRule != null;
    }

    /**
     * Gets the time interval between input measurements provided to the
     * {@link #getDataSource()} expressed in seconds (s).
     *
     * @return time interval between input measurements.
     */
    public double getTimeInterval() {
<span class="fc" id="L704">        return generator.getTimeInterval();</span>
    }

    /**
     * Sets time interval between input measurements provided to the
     * {@link #getDataSource()} expressed in seconds (s).
     *
     * @param timeInterval time interval between input measurements.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L716" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L717">            throw new LockedException();</span>
        }

<span class="fc" id="L720">        generator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L721">    }</span>

    /**
     * Gets the time interval between input measurements provided to the
     * {@link #getDataSource()}.
     *
     * @return time interval between input measurements.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L730">        return generator.getTimeIntervalAsTime();</span>
    }

    /**
     * Gets the time interval between input measurements provided to the
     * {@link #getDataSource()}.
     *
     * @param result instance where the time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L740">        generator.getTimeIntervalAsTime(result);</span>
<span class="fc" id="L741">    }</span>

    /**
     * Sets time interval between input measurements provided to the
     * {@link #getDataSource()}.
     *
     * @param timeInterval time interval between input measurements.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc bfc" id="L752" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L753">            throw new LockedException();</span>
        }

<span class="fc" id="L756">        generator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L757">    }</span>

    /**
     * Gets minimum number of input measurements provided to the
     * {@link #getDataSource()} required in a static interval to be taken
     * into account.
     * Smaller static intervals will be discarded.
     *
     * @return a minimum number of input measurements required in a static interval
     * to be taken into account.
     */
    public int getMinStaticSamples() {
<span class="fc" id="L769">        return generator.getMinStaticSamples();</span>
    }

    /**
     * Sets minimum number of input measurements provided to the
     * {@link #getDataSource()} required in a static interval to be taken
     * into account.
     * Smaller static intervals will be discarded.
     *
     * @param minStaticSamples a minimum number of input measurements required in
     *                         a static interval to be taken into account.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMinStaticSamples(final int minStaticSamples) throws LockedException {
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L785">            throw new LockedException();</span>
        }

<span class="fc" id="L788">        generator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L789">    }</span>

    /**
     * Gets maximum number of input measurements provided to the
     * {@link #getDataSource()} allowed in dynamic intervals.
     *
     * @return maximum number of input measurements allowed in dynamic intervals.
     */
    public int getMaxDynamicSamples() {
<span class="fc" id="L798">        return generator.getMaxDynamicSamples();</span>
    }

    /**
     * Sets maximum number of input measurements provided to the
     * {@link #getDataSource()} allowed in dynamic intervals.
     *
     * @param maxDynamicSamples maximum number of input measurements allowed in
     *                          dynamic intervals.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMaxDynamicSamples(final int maxDynamicSamples) throws LockedException {
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L812">            throw new LockedException();</span>
        }

<span class="fc" id="L815">        generator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L816">    }</span>

    /**
     * Gets length of number of input measurements provided to the
     * {@link #getDataSource()} to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     *
     * @return length of input measurements to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L826">        return generator.getWindowSize();</span>
    }

    /**
     * Sets length of number of input measurements provided to the
     * {@link #getDataSource()} to keep within the window being processed
     * to determine instantaneous noise level.
     * Window size must always be larger than the allowed minimum value, which is 2
     * and must have an odd value.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is not valid.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L841" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L842">            throw new LockedException();</span>
        }

<span class="fc" id="L845">        generator.setWindowSize(windowSize);</span>
<span class="fc" id="L846">    }</span>

    /**
     * Gets number of input measurements provided to the
     * {@link #getDataSource()} to be processed initially while keeping the sensor
     * static to find the base noise level when the device is static.
     *
     * @return number of samples to be processed initially.
     */
    public int getInitialStaticSamples() {
<span class="fc" id="L856">        return generator.getInitialStaticSamples();</span>
    }

    /**
     * Sets number of input parameters provided to the {@link #getDataSource()}
     * to be processed initially while keeping the sensor static to
     * find the base noise level when the device is static.
     *
     * @param initialStaticSamples number of samples ot be processed initially.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is less than
     *                                  {@link TriadStaticIntervalDetector#MINIMUM_INITIAL_STATIC_SAMPLES}.
     */
    public void setInitialStaticSamples(final int initialStaticSamples) throws LockedException {
<span class="fc bfc" id="L870" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L871">            throw new LockedException();</span>
        }

<span class="fc" id="L874">        generator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L875">    }</span>

    /**
     * Gets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @return factor to determine that a sudden movement has occurred.
     */
    public double getInstantaneousNoiseLevelFactor() {
<span class="fc" id="L886">        return generator.getInstantaneousNoiseLevelFactor();</span>
    }

    /**
     * Sets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @param instantaneousNoiseLevelFactor factor to determine that a sudden
     *                                      movement has occurred during
     *                                      initialization.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setInstantaneousNoiseLevelFactor(final double instantaneousNoiseLevelFactor) throws LockedException {
<span class="fc bfc" id="L902" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L903">            throw new LockedException();</span>
        }

<span class="fc" id="L906">        generator.setInstantaneousNoiseLevelFactor(instantaneousNoiseLevelFactor);</span>
<span class="fc" id="L907">    }</span>

    /**
     * Gets the overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @return overall absolute threshold to determine whether there has been
     * excessive motion.
     */
    public double getBaseNoiseLevelAbsoluteThreshold() {
<span class="fc" id="L918">        return generator.getBaseNoiseLevelAbsoluteThreshold();</span>
    }

    /**
     * Sets the overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(final double baseNoiseLevelAbsoluteThreshold)
            throws LockedException {
<span class="fc bfc" id="L934" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L935">            throw new LockedException();</span>
        }

<span class="fc" id="L938">        generator.setBaseNoiseLevelAbsoluteThreshold(baseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L939">    }</span>

    /**
     * Gets the overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     *
     * @return overall absolute threshold to determine whether there has been
     * excessive motion.
     */
    public Acceleration getBaseNoiseLevelAbsoluteThresholdAsMeasurement() {
<span class="fc" id="L949">        return generator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement();</span>
    }

    /**
     * Gets the overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     *
     * @param result instance where the result will be stored.
     */
    public void getBaseNoiseLevelAbsoluteThresholdAsMeasurement(final Acceleration result) {
<span class="fc" id="L959">        generator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(result);</span>
<span class="fc" id="L960">    }</span>

    /**
     * Sets the overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if optimizer is already running.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(final Acceleration baseNoiseLevelAbsoluteThreshold)
            throws LockedException {
<span class="fc bfc" id="L974" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L975">            throw new LockedException();</span>
        }

<span class="fc" id="L978">        generator.setBaseNoiseLevelAbsoluteThreshold(baseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L979">    }</span>

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization of the best solution that has been found expressed in
     * meters per squared second (m/s^2).
     * This is equal to the standard deviation of the accelerometer measurements
     * during the initialization phase.
     *
     * @return accelerometer base noise level of the best solution that has been
     * found.
     */
    public double getAccelerometerBaseNoiseLevel() {
<span class="fc" id="L992">        return baseNoiseLevel;</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization of the best solution that has been found.
     * This is equal to the standard deviation of the accelerometer measurements
     * during the initialization phase.
     *
     * @return accelerometer base noise level of the best solution that has been
     * found.
     */
    public Acceleration getAccelerometerBaseNoiseLevelAsMeasurement() {
<span class="fc" id="L1005">        return createMeasurement(baseNoiseLevel, getDefaultUnit());</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization of the best solution that has been found.
     * This is equal to the standard deviation of the accelerometer measurements
     * during the initialization phase.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerometerBaseNoiseLevelAsMeasurement(final Acceleration result) {
<span class="fc" id="L1017">        result.setValue(baseNoiseLevel);</span>
<span class="fc" id="L1018">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L1019">    }</span>

    /**
     * Gets gyroscope base noise level PSD (Power Spectral Density)
     * expressed in (rad^2/s).
     *
     * @return gyroscope base noise level PSD.
     */
    public double getGyroscopeBaseNoiseLevelPsd() {
<span class="fc" id="L1028">        return angularSpeedNoiseRootPsd * angularSpeedNoiseRootPsd;</span>
    }

    /**
     * Gets gyroscope base noise level root PSD (Power Spectral Density)
     * expressed in (rad * s^-0.5)
     *
     * @return gyroscope base noise level root PSD.
     */
    @Override
    public double getGyroscopeBaseNoiseLevelRootPsd() {
<span class="fc" id="L1039">        return angularSpeedNoiseRootPsd;</span>
    }

    /**
     * Gets accelerometer base noise level PSD (Power Spectral Density)
     * expressed in (m^2 * s^-3).
     *
     * @return accelerometer base noise level PSD.
     */
    public double getAccelerometerBaseNoiseLevelPsd() {
<span class="fc" id="L1049">        return baseNoiseLevel * baseNoiseLevel * getTimeInterval();</span>
    }

    /**
     * Gets accelerometer base noise level root PSD (Power Spectral Density)
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer base noise level root PSD.
     */
    @Override
    public double getAccelerometerBaseNoiseLevelRootPsd() {
<span class="fc" id="L1060">        return baseNoiseLevel * Math.sqrt(getTimeInterval());</span>
    }

    /**
     * Gets the threshold to determine static/dynamic period changes expressed in
     * meters per squared second (m/s^2) for the best calibration solution that
     * has been found.
     *
     * @return threshold to determine static/dynamic period changes for the best
     * solution.
     */
    public double getThreshold() {
<span class="fc" id="L1072">        return threshold;</span>
    }

    /**
     * Gets the threshold to determine static/dynamic period changes for the best
     * calibration solution that has been found.
     *
     * @return threshold to determine static/dynamic period changes for the best
     * solution.
     */
    public Acceleration getThresholdAsMeasurement() {
<span class="fc" id="L1083">        return createMeasurement(threshold, getDefaultUnit());</span>
    }

    /**
     * Get the threshold to determine static/dynamic period changes for the best
     * calibration solution that has been found.
     *
     * @param result instance where the result will be stored.
     */
    public void getThresholdAsMeasurement(final Acceleration result) {
<span class="fc" id="L1093">        result.setValue(threshold);</span>
<span class="fc" id="L1094">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L1095">    }</span>

    /**
     * Gets estimated standard deviation norm of accelerometer bias expressed in
     * meters per squared second (m/s^2).
     * This can be used as the initial accelerometer bias uncertainty for
     * {@link INSLooselyCoupledKalmanInitializerConfig} or {@link INSTightlyCoupledKalmanInitializerConfig}.
     *
     * @return estimated standard deviation norm of accelerometer bias or null
     * if not available.
     */
    public Double getEstimatedAccelerometerBiasStandardDeviationNorm() {
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        return estimatedAccelerometerCovariance != null</span>
<span class="fc" id="L1108">                ? Math.sqrt(getEstimatedAccelerometerBiasFxVariance()</span>
<span class="fc" id="L1109">                + getEstimatedAccelerometerBiasFyVariance()</span>
<span class="fc" id="L1110">                + getEstimatedAccelerometerBiasFzVariance())</span>
<span class="fc" id="L1111">                : null;</span>
    }

    /**
     * Gets estimated x coordinate variance of accelerometer bias expressed in (m^2/s^4).
     *
     * @return estimated x coordinate variance of accelerometer bias or null if not available.
     */
    public Double getEstimatedAccelerometerBiasFxVariance() {
<span class="fc bfc" id="L1120" title="All 2 branches covered.">        return estimatedAccelerometerCovariance != null</span>
<span class="fc" id="L1121">                ? estimatedAccelerometerCovariance.getElementAt(0, 0) : null;</span>
    }

    /**
     * Gets estimated y coordinate variance of accelerometer bias expressed in (m^2/s^4).
     *
     * @return estimated y coordinate variance of accelerometer bias or null if not available.
     */
    public Double getEstimatedAccelerometerBiasFyVariance() {
<span class="fc bfc" id="L1130" title="All 2 branches covered.">        return estimatedAccelerometerCovariance != null</span>
<span class="fc" id="L1131">                ? estimatedAccelerometerCovariance.getElementAt(1, 1) : null;</span>
    }

    /**
     * Gets estimated z coordinate variance of accelerometer bias expressed in (m^2/s^4).
     *
     * @return estimated z coordinate variance of accelerometer bias or null if not available.
     */
    public Double getEstimatedAccelerometerBiasFzVariance() {
<span class="fc bfc" id="L1140" title="All 2 branches covered.">        return estimatedAccelerometerCovariance != null</span>
<span class="fc" id="L1141">                ? estimatedAccelerometerCovariance.getElementAt(2, 2) : null;</span>
    }

    /**
     * Gets the array containing x,y,z components of estimated accelerometer biases
     * expressed in meters per squared second (m/s^2).
     *
     * @return array containing x,y,z components of estimated accelerometer biases.
     */
    public double[] getEstimatedAccelerometerBiases() {
<span class="fc" id="L1151">        return estimatedAccelerometerBiases;</span>
    }

    /**
     * Gets estimated accelerometer scale factors and cross-coupling errors.
     * This is the product of matrix Ta containing cross-coupling errors and Ka
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix. However, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     *
     * @return estimated accelerometer scale factors and cross-coupling errors, or null
     * if not available.
     */
    public Matrix getEstimatedAccelerometerMa() {
<span class="fc" id="L1197">        return estimatedAccelerometerMa;</span>
    }

    /**
     * Gets estimated standard deviation norm of gyroscope bias expressed in
     * radians per second (rad/s).
     * This can be used as the initial gyroscope bias uncertainty for
     * {@link INSLooselyCoupledKalmanInitializerConfig} or {@link INSTightlyCoupledKalmanInitializerConfig}.
     *
     * @return estimated standard deviation norm of gyroscope bias or null
     * if not available.
     */
    public Double getEstimatedGyroscopeBiasStandardDeviationNorm() {
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        return estimatedGyroscopeCovariance != null</span>
<span class="fc" id="L1211">                ? Math.sqrt(getEstimatedGyroscopeBiasXVariance()</span>
<span class="fc" id="L1212">                + getEstimatedGyroscopeBiasYVariance()</span>
<span class="fc" id="L1213">                + getEstimatedGyroscopeBiasZVariance())</span>
<span class="fc" id="L1214">                : null;</span>
    }

    /**
     * Gets estimated x coordinate variance of gyroscope bias expressed in (rad^2/s^2).
     *
     * @return estimated x coordinate variance of gyroscope bias or null if not available.
     */
    public Double getEstimatedGyroscopeBiasXVariance() {
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        return estimatedGyroscopeCovariance != null</span>
<span class="fc" id="L1224">                ? estimatedGyroscopeCovariance.getElementAt(0, 0) : null;</span>
    }

    /**
     * Gets estimated y coordinate variance of gyroscope bias expressed in (rad^2/s^2).
     *
     * @return estimated y coordinate variance of gyroscope bias or null if not available.
     */
    public Double getEstimatedGyroscopeBiasYVariance() {
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        return estimatedGyroscopeCovariance != null</span>
<span class="fc" id="L1234">                ? estimatedGyroscopeCovariance.getElementAt(1, 1) : null;</span>
    }

    /**
     * Gets estimated z coordinate variance of gyroscope bias expressed in (rad^2/s^2).
     *
     * @return estimated z coordinate variance of gyroscope bias or null if not available.
     */
    public Double getEstimatedGyroscopeBiasZVariance() {
<span class="fc bfc" id="L1243" title="All 2 branches covered.">        return estimatedGyroscopeCovariance != null</span>
<span class="fc" id="L1244">                ? estimatedGyroscopeCovariance.getElementAt(2, 2) : null;</span>
    }

    /**
     * Gets the array containing x,y,z components of estimated gyroscope biases
     * expressed in radians per second (rad/s).
     *
     * @return array containing x,y,z components of estimated gyroscope biases.
     */
    public double[] getEstimatedGyroscopeBiases() {
<span class="fc" id="L1254">        return estimatedGyroscopeBiases;</span>
    }

    /**
     * Gets estimated gyroscope scale factors and cross-coupling errors.
     * This is the product of matrix Tg containing cross-coupling errors and Kg
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix. However, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the gyroscope z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Mg matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     *
     * @return estimated gyroscope scale factors and cross-coupling errors.
     */
    public Matrix getEstimatedGyroscopeMg() {
<span class="fc" id="L1299">        return estimatedGyroscopeMg;</span>
    }

    /**
     * Gets estimated G-dependent cross-biases introduced on the gyroscope by the
     * specific forces sensed by the accelerometer.
     *
     * @return a 3x3 matrix containing g-dependent cross biases.
     */
    public Matrix getEstimatedGyroscopeGg() {
<span class="fc" id="L1309">        return estimatedGyroscopeGg;</span>
    }

    /**
     * Gets the array containing x,y,z components of estimated magnetometer
     * hard-iron biases expressed in Teslas (T).
     *
     * @return array containing x,y,z components of estimated magnetometer
     * hard-iron biases.
     */
    public double[] getEstimatedMagnetometerHardIron() {
<span class="fc" id="L1320">        return estimatedMagnetometerHardIron;</span>
    }

    /**
     * Gets estimated magnetometer soft-iron matrix containing scale factors
     * and cross-coupling errors.
     * This is the product of matrix Tm containing cross-coupling errors and Km
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Mm = [sx    mxy  mxz] = Tm*Km
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Km = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tm = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mm = [sx    mxy  mxz] = Tm*Km =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix. However, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Mm matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Mm = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     *
     * @return estimated magnetometer soft-iron scale factors and cross-coupling errors,
     * or null if not available.
     */
    public Matrix getEstimatedMagnetometerMm() {
<span class="fc" id="L1367">        return estimatedMagnetometerMm;</span>
    }

    /**
     * Evaluates calibration Mean Square Error (MSE) for the provided threshold factor.
     *
     * @param thresholdFactor threshold factor to be used for interval detection
     *                        and measurement generation to be used for
     *                        calibration.
     * @return calibration MSE.
     * @throws LockedException                                   if the generator is busy.
     * @throws CalibrationException                              if calibration fails.
     * @throws NotReadyException                                 if the calibrator is not ready.
     * @throws IntervalDetectorThresholdFactorOptimizerException interval detection failed.
     */
    protected double evaluateForThresholdFactor(final double thresholdFactor) throws LockedException,
            CalibrationException, NotReadyException, IntervalDetectorThresholdFactorOptimizerException {
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        if (accelerometerMeasurements == null) {</span>
<span class="fc" id="L1385">            accelerometerMeasurements = new ArrayList&lt;&gt;();</span>
        } else {
<span class="fc" id="L1387">            accelerometerMeasurements.clear();</span>
        }

<span class="fc bfc" id="L1390" title="All 2 branches covered.">        if (gyroscopeSequences == null) {</span>
<span class="fc" id="L1391">            gyroscopeSequences = new ArrayList&lt;&gt;();</span>
        } else {
<span class="fc" id="L1393">            gyroscopeSequences.clear();</span>
        }

<span class="fc bfc" id="L1396" title="All 2 branches covered.">        if (magnetometerMeasurements == null) {</span>
<span class="fc" id="L1397">            magnetometerMeasurements = new ArrayList&lt;&gt;();</span>
        } else {
<span class="fc" id="L1399">            magnetometerMeasurements.clear();</span>
        }

<span class="fc" id="L1402">        generator.reset();</span>
<span class="fc" id="L1403">        generator.setThresholdFactor(thresholdFactor);</span>

<span class="fc" id="L1405">        var count = dataSource.count();</span>
<span class="fc" id="L1406">        var failed = false;</span>
<span class="fc bfc" id="L1407" title="All 2 branches covered.">        for (var i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L1408">            final var timedBodyKinematics = dataSource.getAt(i);</span>
<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">            if (!generator.process(timedBodyKinematics)) {</span>
<span class="nc" id="L1410">                failed = true;</span>
<span class="nc" id="L1411">                break;</span>
            }
        }

<span class="pc bpc" id="L1415" title="2 of 4 branches missed.">        if (failed || generator.getStatus() == TriadStaticIntervalDetector.Status.FAILED) {</span>
            // interval detection failed
<span class="nc" id="L1417">            return Double.MAX_VALUE;</span>
        }

        // check that enough measurements have been obtained
<span class="pc bpc" id="L1421" title="1 of 2 branches missed.">        if (accelerometerMeasurements.size() &lt; accelerometerCalibrator.getMinimumRequiredMeasurements()</span>
<span class="pc bpc" id="L1422" title="1 of 2 branches missed.">                || gyroscopeSequences.size() &lt; gyroscopeCalibrator.getMinimumRequiredMeasurementsOrSequences()</span>
<span class="pc bpc" id="L1423" title="1 of 2 branches missed.">                || magnetometerMeasurements.size() &lt; magnetometerCalibrator.getMinimumRequiredMeasurements()) {</span>
<span class="nc" id="L1424">            return Double.MAX_VALUE;</span>
        }

        // set calibrator measurements
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">        switch (accelerometerCalibrator.getMeasurementType()) {</span>
            case STANDARD_DEVIATION_BODY_KINEMATICS:
<span class="fc bfc" id="L1430" title="All 2 branches covered.">                if (accelerometerCalibrator.isOrderedMeasurementsRequired()) {</span>
<span class="fc" id="L1431">                    final var calibrator =</span>
                            (OrderedStandardDeviationBodyKinematicsAccelerometerCalibrator) accelerometerCalibrator;

<span class="fc" id="L1434">                    calibrator.setMeasurements(accelerometerMeasurements);</span>

<span class="fc" id="L1436">                } else {</span>
<span class="fc" id="L1437">                    final var calibrator =</span>
                            (UnorderedStandardDeviationBodyKinematicsAccelerometerCalibrator) accelerometerCalibrator;

<span class="fc" id="L1440">                    calibrator.setMeasurements(accelerometerMeasurements);</span>
                }

<span class="fc bfc" id="L1443" title="All 2 branches covered.">                if (accelerometerCalibrator.isQualityScoresRequired()) {</span>
<span class="fc" id="L1444">                    final var calibrator = (QualityScoredAccelerometerCalibrator) accelerometerCalibrator;</span>

<span class="fc" id="L1446">                    final var size = accelerometerMeasurements.size();</span>
<span class="fc" id="L1447">                    final var qualityScores = new double[size];</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">                    for (var i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1449">                        qualityScores[i] = accelerometerQualityScoreMapper.map(accelerometerMeasurements.get(i));</span>
                    }
<span class="fc" id="L1451">                    calibrator.setQualityScores(qualityScores);</span>
<span class="fc" id="L1452">                }</span>
                break;
            case FRAME_BODY_KINEMATICS, STANDARD_DEVIATION_FRAME_BODY_KINEMATICS:
                // Throw exception. Cannot use frames
            default:
<span class="nc" id="L1457">                throw new IntervalDetectorThresholdFactorOptimizerException();</span>
        }

<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">        if (gyroscopeCalibrator.getMeasurementOrSequenceType()</span>
                == GyroscopeCalibratorMeasurementOrSequenceType.BODY_KINEMATICS_SEQUENCE) {
<span class="fc" id="L1462">            final var calibrator = (OrderedBodyKinematicsSequenceGyroscopeCalibrator) gyroscopeCalibrator;</span>

<span class="fc" id="L1464">            calibrator.setSequences(gyroscopeSequences);</span>
<span class="fc" id="L1465">        } else {</span>
<span class="nc" id="L1466">            throw new IntervalDetectorThresholdFactorOptimizerException();</span>
        }

<span class="fc bfc" id="L1469" title="All 2 branches covered.">        if (gyroscopeCalibrator.isQualityScoresRequired()) {</span>
<span class="fc" id="L1470">            final var calibrator = (QualityScoredGyroscopeCalibrator) gyroscopeCalibrator;</span>

<span class="fc" id="L1472">            final var size = gyroscopeSequences.size();</span>
<span class="fc" id="L1473">            final var qualityScores = new double[size];</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">            for (var i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1475">                qualityScores[i] = gyroscopeQualityScoreMapper.map(gyroscopeSequences.get(i));</span>
            }
<span class="fc" id="L1477">            calibrator.setQualityScores(qualityScores);</span>
        }

<span class="pc bpc" id="L1480" title="1 of 2 branches missed.">        switch (magnetometerCalibrator.getMeasurementType()) {</span>
            case STANDARD_DEVIATION_BODY_MAGNETIC_FLUX_DENSITY:
<span class="fc bfc" id="L1482" title="All 2 branches covered.">                if (magnetometerCalibrator.isOrderedMeasurementsRequired()) {</span>
<span class="fc" id="L1483">                    final var calibrator = (OrderedStandardDeviationBodyMagneticFluxDensityMagnetometerCalibrator)</span>
                            magnetometerCalibrator;

<span class="fc" id="L1486">                    calibrator.setMeasurements(magnetometerMeasurements);</span>
<span class="fc" id="L1487">                } else {</span>
<span class="fc" id="L1488">                    final var calibrator = (UnorderedStandardDeviationBodyMagneticFluxDensityMagnetometerCalibrator)</span>
                            magnetometerCalibrator;

<span class="fc" id="L1491">                    calibrator.setMeasurements(magnetometerMeasurements);</span>
                }

<span class="fc bfc" id="L1494" title="All 2 branches covered.">                if (magnetometerCalibrator.isQualityScoresRequired()) {</span>
<span class="fc" id="L1495">                    final var calibrator = (QualityScoredMagnetometerCalibrator) magnetometerCalibrator;</span>

<span class="fc" id="L1497">                    final var size = magnetometerMeasurements.size();</span>
<span class="fc" id="L1498">                    final var qualityScores = new double[size];</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">                    for (var i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1500">                        qualityScores[i] = magnetometerQualityScoreMapper.map(magnetometerMeasurements.get(i));</span>
                    }
<span class="fc" id="L1502">                    calibrator.setQualityScores(qualityScores);</span>
<span class="fc" id="L1503">                }</span>
                break;
            case FRAME_BODY_MAGNETIC_FLUX_DENSITY, STANDARD_DEVIATION_FRAME_BODY_MAGNETIC_FLUX_DENSITY:
                // Throw exception. Cannot use frames
            default:
<span class="nc" id="L1508">                throw new IntervalDetectorThresholdFactorOptimizerException();</span>
        }

<span class="fc" id="L1511">        accelerometerCalibrator.calibrate();</span>

        // once we have accelerometer estimations, we can set known
        // accelerometer bias and cross-coupling errors to the gyroscope calibrator
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">        if (gyroscopeCalibrator instanceof AccelerometerDependentGyroscopeCalibrator accelGyroCalibrator) {</span>

            final double[] bias;
<span class="pc bpc" id="L1518" title="1 of 2 branches missed.">            if (accelerometerCalibrator instanceof UnknownBiasAccelerometerCalibrator unknownBiasAccelerometerCalibrator) {</span>
<span class="fc" id="L1519">                bias = unknownBiasAccelerometerCalibrator.getEstimatedBiases();</span>

<span class="nc bnc" id="L1521" title="All 2 branches missed.">            } else if (accelerometerCalibrator instanceof KnownBiasAccelerometerCalibrator knownBiasAccelerometerCalibrator) {</span>
<span class="nc" id="L1522">                bias = knownBiasAccelerometerCalibrator.getBias();</span>
            } else {
<span class="nc" id="L1524">                bias = null;</span>
            }

<span class="pc bpc" id="L1527" title="1 of 2 branches missed.">            if (bias != null) {</span>
<span class="fc" id="L1528">                accelGyroCalibrator.setAccelerometerBias(bias);</span>
<span class="fc" id="L1529">                accelGyroCalibrator.setAccelerometerMa(accelerometerCalibrator.getEstimatedMa());</span>
            }
        }

<span class="fc" id="L1533">        gyroscopeCalibrator.calibrate();</span>
<span class="fc" id="L1534">        magnetometerCalibrator.calibrate();</span>

<span class="fc" id="L1536">        final var accelerometerMse = accelerometerCalibrator.getEstimatedMse();</span>
<span class="fc" id="L1537">        final var gyroscopeMse = gyroscopeCalibrator.getEstimatedMse();</span>
<span class="fc" id="L1538">        final var magnetometerMse = magnetometerCalibrator.getEstimatedMse();</span>

        // convert accelerometer and gyroscope mse to global mse
<span class="fc" id="L1541">        final var mse = mseRule.evaluate(accelerometerMse, gyroscopeMse, magnetometerMse);</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">        if (mse &lt; minMse) {</span>
<span class="fc" id="L1543">            keepBestResult(mse, thresholdFactor);</span>
        }
<span class="fc" id="L1545">        return mse;</span>
    }

    /**
     * Initializes accelerometer, gyroscope and magnetometer measurement generator to
     * convert {@link TimedBodyKinematicsAndMagneticFluxDensity} measurements after
     * interval detection into measurements and sequences used for accelerometer,
     * gyroscope and magnetometer calibration.
     */
    private void initialize() {
<span class="fc" id="L1555">        final var generatorListener = new AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener() {</span>
            @Override
            public void onInitializationStarted(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator) {
                // not needed
<span class="fc" id="L1560">            }</span>

            @Override
            public void onInitializationCompleted(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator,
                    final double accelerometerBaseNoiseLevel) {
                // not needed
<span class="fc" id="L1567">            }</span>

            @Override
            public void onError(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator,
                    final TriadStaticIntervalDetector.ErrorReason reason) {
                // not needed
<span class="nc" id="L1574">            }</span>

            @Override
            public void onStaticIntervalDetected(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator) {
                // not needed
<span class="fc" id="L1580">            }</span>

            @Override
            public void onDynamicIntervalDetected(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator) {
                // not needed
<span class="fc" id="L1586">            }</span>

            @Override
            public void onStaticIntervalSkipped(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator) {
                // not needed
<span class="nc" id="L1592">            }</span>

            @Override
            public void onDynamicIntervalSkipped(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator) {
                // not needed
<span class="nc" id="L1598">            }</span>

            @Override
            public void onGeneratedAccelerometerMeasurement(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator,
                    final StandardDeviationBodyKinematics measurement) {
<span class="fc" id="L1604">                accelerometerMeasurements.add(measurement);</span>
<span class="fc" id="L1605">            }</span>

            @Override
            public void onGeneratedGyroscopeMeasurement(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator,
                    final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence) {
<span class="fc" id="L1611">                gyroscopeSequences.add(sequence);</span>
<span class="fc" id="L1612">            }</span>

            @Override
            public void onGeneratedMagnetometerMeasurement(
                    final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator,
                    final StandardDeviationBodyMagneticFluxDensity measurement) {
<span class="fc" id="L1618">                magnetometerMeasurements.add(measurement);</span>
<span class="fc" id="L1619">            }</span>

            @Override
            public void onReset(final AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator generator) {
                // not needed
<span class="fc" id="L1624">            }</span>
        };

<span class="fc" id="L1627">        generator = new AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator(generatorListener);</span>
<span class="fc" id="L1628">    }</span>

    /**
     * Keeps the best calibration solution found so far.
     *
     * @param mse             Estimated Mean Square Error during calibration.
     * @param thresholdFactor threshold factor to be kept.
     */
    private void keepBestResult(final double mse, final double thresholdFactor) {
<span class="fc" id="L1637">        minMse = mse;</span>
<span class="fc" id="L1638">        optimalThresholdFactor = thresholdFactor;</span>

<span class="fc" id="L1640">        angularSpeedNoiseRootPsd = generator.getGyroscopeBaseNoiseLevelRootPsd();</span>
<span class="fc" id="L1641">        baseNoiseLevel = generator.getAccelerometerBaseNoiseLevel();</span>
<span class="fc" id="L1642">        threshold = generator.getThreshold();</span>

<span class="fc bfc" id="L1644" title="All 2 branches covered.">        if (estimatedAccelerometerCovariance == null) {</span>
<span class="fc" id="L1645">            estimatedAccelerometerCovariance = new Matrix(accelerometerCalibrator.getEstimatedCovariance());</span>
        } else {
<span class="fc" id="L1647">            estimatedAccelerometerCovariance.copyFrom(accelerometerCalibrator.getEstimatedCovariance());</span>
        }
<span class="fc bfc" id="L1649" title="All 2 branches covered.">        if (estimatedAccelerometerMa == null) {</span>
<span class="fc" id="L1650">            estimatedAccelerometerMa = new Matrix(accelerometerCalibrator.getEstimatedMa());</span>
        } else {
<span class="fc" id="L1652">            estimatedAccelerometerMa.copyFrom(accelerometerCalibrator.getEstimatedMa());</span>
        }
<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">        if (accelerometerCalibrator instanceof UnknownBiasAccelerometerCalibrator unknownBiasAccelerometerCalibrator) {</span>
<span class="fc" id="L1655">            estimatedAccelerometerBiases = unknownBiasAccelerometerCalibrator.getEstimatedBiases();</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">        } else if (accelerometerCalibrator instanceof KnownBiasAccelerometerCalibrator knownBiasAccelerometerCalibrator) {</span>
<span class="nc" id="L1657">            estimatedAccelerometerBiases = knownBiasAccelerometerCalibrator.getBias();</span>
        }

<span class="fc bfc" id="L1660" title="All 2 branches covered.">        if (estimatedGyroscopeCovariance == null) {</span>
<span class="fc" id="L1661">            estimatedGyroscopeCovariance = new Matrix(gyroscopeCalibrator.getEstimatedCovariance());</span>
        } else {
<span class="fc" id="L1663">            estimatedGyroscopeCovariance.copyFrom(gyroscopeCalibrator.getEstimatedCovariance());</span>
        }
<span class="fc bfc" id="L1665" title="All 2 branches covered.">        if (estimatedGyroscopeMg == null) {</span>
<span class="fc" id="L1666">            estimatedGyroscopeMg = new Matrix(gyroscopeCalibrator.getEstimatedMg());</span>
        } else {
<span class="fc" id="L1668">            estimatedGyroscopeMg.copyFrom(gyroscopeCalibrator.getEstimatedMg());</span>
        }
<span class="fc bfc" id="L1670" title="All 2 branches covered.">        if (estimatedGyroscopeGg == null) {</span>
<span class="fc" id="L1671">            estimatedGyroscopeGg = new Matrix(gyroscopeCalibrator.getEstimatedGg());</span>
        } else {
<span class="fc" id="L1673">            estimatedGyroscopeGg.copyFrom(gyroscopeCalibrator.getEstimatedGg());</span>
        }
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">        if (gyroscopeCalibrator instanceof UnknownBiasGyroscopeCalibrator unknownBiasGyroscopeCalibrator) {</span>
<span class="fc" id="L1676">            estimatedGyroscopeBiases = unknownBiasGyroscopeCalibrator.getEstimatedBiases();</span>
<span class="nc bnc" id="L1677" title="All 2 branches missed.">        } else if (gyroscopeCalibrator instanceof KnownBiasAccelerometerCalibrator knownBiasAccelerometerCalibrator) {</span>
<span class="nc" id="L1678">            estimatedGyroscopeBiases = knownBiasAccelerometerCalibrator.getBias();</span>
        }

<span class="fc bfc" id="L1681" title="All 2 branches covered.">        if (estimatedMagnetometerCovariance == null) {</span>
<span class="fc" id="L1682">            estimatedMagnetometerCovariance = new Matrix(magnetometerCalibrator.getEstimatedCovariance());</span>
        } else {
<span class="fc" id="L1684">            estimatedMagnetometerCovariance.copyFrom(magnetometerCalibrator.getEstimatedCovariance());</span>
        }
<span class="fc bfc" id="L1686" title="All 2 branches covered.">        if (estimatedMagnetometerMm == null) {</span>
<span class="fc" id="L1687">            estimatedMagnetometerMm = new Matrix(magnetometerCalibrator.getEstimatedMm());</span>
        } else {
<span class="fc" id="L1689">            estimatedMagnetometerMm.copyFrom(magnetometerCalibrator.getEstimatedMm());</span>
        }
<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">        if (magnetometerCalibrator instanceof UnknownHardIronMagnetometerCalibrator unknownHardIronMagnetometerCalibrator) {</span>
<span class="fc" id="L1692">            estimatedMagnetometerHardIron = unknownHardIronMagnetometerCalibrator.getEstimatedHardIron();</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">        } else if (magnetometerCalibrator instanceof KnownHardIronMagnetometerCalibrator knownHardIronMagnetometerCalibrator) {</span>
<span class="nc" id="L1694">            estimatedMagnetometerHardIron = knownHardIronMagnetometerCalibrator.getHardIron();</span>
        }
<span class="fc" id="L1696">    }</span>

    /**
     * Creates an acceleration instance using the provided value and unit.
     *
     * @param value value of measurement.
     * @param unit  unit of value.
     * @return created acceleration.
     */
    private Acceleration createMeasurement(final double value, final AccelerationUnit unit) {
<span class="fc" id="L1706">        return new Acceleration(value, unit);</span>
    }

    /**
     * Gets the default unit for acceleration, which is meters per
     * squared second (m/s^2).
     *
     * @return default unit for acceleration.
     */
    private AccelerationUnit getDefaultUnit() {
<span class="fc" id="L1716">        return AccelerationUnit.METERS_PER_SQUARED_SECOND;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>