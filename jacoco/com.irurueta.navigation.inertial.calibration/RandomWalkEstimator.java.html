<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RandomWalkEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial-extra</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">RandomWalkEstimator.java</span></div><h1>RandomWalkEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2021 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Point3D;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.ECEFPosition;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.frames.NEDFrame;
import com.irurueta.navigation.frames.NEDPosition;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.INSLooselyCoupledKalmanConfig;
import com.irurueta.navigation.inertial.calibration.bias.BodyKinematicsBiasEstimator;
import com.irurueta.units.Acceleration;
import com.irurueta.units.Angle;
import com.irurueta.units.AngleUnit;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.Distance;
import com.irurueta.units.DistanceUnit;
import com.irurueta.units.Speed;
import com.irurueta.units.SpeedUnit;
import com.irurueta.units.Time;
import com.irurueta.units.TimeUnit;

/**
 * Estimates random walk data by running this estimator while the body of IMU remains static
 * at a given position and orientation when IMU has already been calibrated.
 * Internally, this estimator accumulates samples for a given &quot;drift period&quot; to
 * estimate accumulated drift values of position, velocity and attitude, and then
 * repeats the process several times to estimate the mean and variance of such values.
 * The duration of the drift period is application-dependent. It should be set
 * to a value more or less similar to the amount of time the device won't be able
 * to set a position by some other system (e.g., GPS, Wi-Fi, cameras, etc...)
 */
public class RandomWalkEstimator implements AccelerometerBiasRandomWalkSource,
        GyroscopeBiasRandomWalkSource, PositionUncertaintySource,
        VelocityUncertaintySource, AttitudeUncertaintySource,
        PositionNoiseStandardDeviationSource, VelocityNoiseStandardDeviationSource {

    /**
     * Number of samples to be used by default on each drift period.
     */
    public static final int DEFAULT_DRIFT_PERIOD_SAMPLES = 150;

    /**
     * Listener to handle events raised by this estimator.
     */
    private RandomWalkEstimatorListener listener;

    /**
     * Fixes body kinematics measurements using accelerometer and gyroscope
     * calibration data to fix measurements.
     */
<span class="fc" id="L72">    private final BodyKinematicsFixer fixer = new BodyKinematicsFixer();</span>

    /**
     * Estimates bias for fixed body kinematics measurements to determine further
     * bias variations while the IMU body remains static.
     */
<span class="fc" id="L78">    private final BodyKinematicsBiasEstimator biasEstimator = new BodyKinematicsBiasEstimator();</span>

    /**
     * Estimates amount of position, velocity and orientation drift.
     */
<span class="fc" id="L83">    private final DriftEstimator driftEstimator = new DriftEstimator();</span>

    /**
     * Instance containing the last fixed body kinematics to be reused.
     */
<span class="fc" id="L88">    private final BodyKinematics fixedKinematics = new BodyKinematics();</span>

    /**
     * Indicates whether measured kinematics must be fixed or not.
     * When enabled, provided calibration data is used; otherwise it is
     * ignored.
     * By default, this is enabled.
     */
<span class="fc" id="L96">    private boolean fixKinematics = true;</span>

    /**
     * Number of samples to be used on each drift period.
     */
<span class="fc" id="L101">    private int driftPeriodSamples = DEFAULT_DRIFT_PERIOD_SAMPLES;</span>

    /**
     * Indicates whether this estimator is running or not.
     */
    private boolean running;

    /**
     * Number of drift periods that have been processed.
     */
    private int numberOfProcessedDriftPeriods;

    /**
     * Accelerometer bias random walk PSD (Power Spectral Density) expressed
     * in (m^2 * s^-5).
     */
    private double accelerometerBiasPSD;

    /**
     * Gyro bias random walk PSD (Power Spectral Density) expressed in (rad^2 * s^-3).
     */
    private double gyroBiasPSD;

    /**
     * Average position drift expressed in meters (m).
     * This gives a sign of position accuracy.
     */
    private double avgPositionDrift;

    /**
     * Average velocity drift expressed in meters per second (m/s).
     */
    private double avgVelocityDrift;

    /**
     * Average attitude drift expressed in radians (rad).
     */
    private double avgAttitudeDrift;

    /**
     * Position variance expressed in square meters (m^2).
     */
    private double varPositionDrift;

    /**
     * Velocity variance expressed in (m^2/s^2).
     */
    private double varVelocityDrift;

    /**
     * Attitude variance expressed in squared radians (rad^2).
     */
    private double varAttitudeDrift;

    /**
     * Contains acceleration triad to be reused for bias norm estimation.
     * This is reused for efficiency.
     */
<span class="fc" id="L159">    private final AccelerationTriad accelerationTriad = new AccelerationTriad();</span>

    /**
     * Contains angular speed triad to be reused for bias norm estimation.
     * This is reused for efficiency.
     */
<span class="fc" id="L165">    private final AngularSpeedTriad angularSpeedTriad = new AngularSpeedTriad();</span>

    /**
     * Constructor.
     */
<span class="fc" id="L170">    public RandomWalkEstimator() {</span>
<span class="fc" id="L171">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events.
     */
<span class="fc" id="L178">    public RandomWalkEstimator(final RandomWalkEstimatorListener listener) {</span>
<span class="fc" id="L179">        this.listener = listener;</span>
<span class="fc" id="L180">    }</span>

    /**
     * Constructor.
     *
     * @param ba acceleration bias to be set.
     * @param ma acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg angular speed bias to be set.
     * @param mg angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
<span class="fc" id="L197">            final Matrix mg) throws AlgebraException {</span>
        try {
<span class="fc" id="L199">            setAccelerationBias(ba);</span>
<span class="fc" id="L200">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L201">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L202">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="nc" id="L203">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L205">        }</span>
<span class="fc" id="L206">    }</span>

    /**
     * Constructor.
     *
     * @param ba       acceleration bias to be set.
     * @param ma       acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg       angular speed bias to be set.
     * @param mg       angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final RandomWalkEstimatorListener listener)
            throws AlgebraException {
<span class="fc" id="L227">        this(ba, ma, bg, mg);</span>
<span class="fc" id="L228">        this.listener = listener;</span>
<span class="fc" id="L229">    }</span>

    /**
     * Constructor.
     *
     * @param ba acceleration bias to be set.
     * @param ma acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg angular speed bias to be set.
     * @param mg angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg) throws AlgebraException {
<span class="fc" id="L249">        this(ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L251">            setAngularSpeedGDependantCrossBias(gg);</span>
<span class="nc" id="L252">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L254">        }</span>
<span class="fc" id="L255">    }</span>

    /**
     * Constructor.
     *
     * @param ba       acceleration bias to be set.
     * @param ma       acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg       angular speed bias to be set.
     * @param mg       angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg       angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final RandomWalkEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L277">        this(ba, ma, bg, mg, gg);</span>
<span class="fc" id="L278">        this.listener = listener;</span>
<span class="fc" id="L279">    }</span>

    /**
     * Constructor.
     *
     * @param ba acceleration bias to be set expressed in meters per squared second
     *           (m/s`2). Must be 3x1.
     * @param ma acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg angular speed bias to be set expressed in radians per second
     *           (rad/s). Must be 3x1.
     * @param mg angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any of the provided matrices do not have a proper
     *                                  size.
     */
    public RandomWalkEstimator(
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
<span class="fc" id="L299">            final Matrix mg) throws AlgebraException {</span>
        try {
<span class="fc" id="L301">            setAccelerationBias(ba);</span>
<span class="fc" id="L302">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L303">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L304">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="nc" id="L305">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L307">        }</span>
<span class="fc" id="L308">    }</span>

    /**
     * Constructor.
     *
     * @param ba       acceleration bias to be set expressed in meters per squared second
     *                 (m/s`2). Must be 3x1.
     * @param ma       acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg       angular speed bias to be set expressed in radians per second
     *                 (rad/s). Must be 3x1.
     * @param mg       angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any of the provided matrices do not have a proper
     *                                  size.
     */
    public RandomWalkEstimator(
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final RandomWalkEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L331">        this(ba, ma, bg, mg);</span>
<span class="fc" id="L332">        this.listener = listener;</span>
<span class="fc" id="L333">    }</span>

    /**
     * Constructor.
     *
     * @param ba acceleration bias to be set expressed in meters per squared second
     *           (m/s`2). Must be 3x1.
     * @param ma acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg angular speed bias to be set expressed in radians per second
     *           (rad/s). Must be 3x1.
     * @param mg angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any of the provided matrices do not have a proper
     *                                  size.
     */
    public RandomWalkEstimator(
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg) throws AlgebraException {
<span class="fc" id="L356">        this(ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L358">            setAngularSpeedGDependantCrossBias(gg);</span>
<span class="nc" id="L359">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L361">        }</span>
<span class="fc" id="L362">    }</span>

    /**
     * Constructor.
     *
     * @param ba       acceleration bias to be set expressed in meters per squared second
     *                 (m/s`2). Must be 3x1.
     * @param ma       acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg       angular speed bias to be set expressed in radians per second
     *                 (rad/s). Must be 3x1.
     * @param mg       angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg       angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any of the provided matrices do not have a proper
     *                                  size.
     */
    public RandomWalkEstimator(
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final RandomWalkEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L387">        this(ba, ma, bg, mg, gg);</span>
<span class="fc" id="L388">        this.listener = listener;</span>
<span class="fc" id="L389">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
<span class="fc" id="L403">            final CoordinateTransformation nedC) throws InvalidSourceAndDestinationFrameTypeException {</span>
        try {
<span class="fc" id="L405">            setNedPositionAndNedOrientation(nedPosition, nedC);</span>
<span class="nc" id="L406">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L408">        }</span>
<span class="fc" id="L409">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param listener    listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L426">        this(nedPosition, nedC);</span>
<span class="fc" id="L427">        this.listener = listener;</span>
<span class="fc" id="L428">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param ba          acceleration bias to be set.
     * @param ma          acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg          angular speed bias to be set.
     * @param mg          angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L454">        this(nedPosition, nedC);</span>
        try {
<span class="fc" id="L456">            setAccelerationBias(ba);</span>
<span class="fc" id="L457">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L458">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L459">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="nc" id="L460">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L462">        }</span>
<span class="fc" id="L463">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param ba          acceleration bias to be set.
     * @param ma          acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg          angular speed bias to be set.
     * @param mg          angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener    listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L492">        this(nedPosition, nedC, ba, ma, bg, mg);</span>
<span class="fc" id="L493">        this.listener = listener;</span>
<span class="fc" id="L494">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param ba          acceleration bias to be set.
     * @param ma          acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg          angular speed bias to be set.
     * @param mg          angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg          angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L522">        this(nedPosition, nedC);</span>
        try {
<span class="fc" id="L524">            setAccelerationBias(ba);</span>
<span class="fc" id="L525">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L526">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L527">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="fc" id="L528">            setAngularSpeedGDependantCrossBias(gg);</span>
<span class="nc" id="L529">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L531">        }</span>
<span class="fc" id="L532">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param ba          acceleration bias to be set.
     * @param ma          acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg          angular speed bias to be set.
     * @param mg          angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg          angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener    listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L563">        this(nedPosition, nedC, ba, ma, bg, mg, gg);</span>
<span class="fc" id="L564">        this.listener = listener;</span>
<span class="fc" id="L565">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param ba          acceleration bias to be set expressed in meters per squared second
     *                    (m/s`2). Must be 3x1.
     * @param ma          acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg          angular speed bias to be set expressed in radians per second
     *                    (rad/s). Must be 3x1.
     * @param mg          angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L593">        this(nedPosition, nedC);</span>
        try {
<span class="fc" id="L595">            setAccelerationBias(ba);</span>
<span class="fc" id="L596">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L597">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L598">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="nc" id="L599">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L601">        }</span>
<span class="fc" id="L602">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param ba          acceleration bias to be set expressed in meters per squared second
     *                    (m/s`2). Must be 3x1.
     * @param ma          acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg          angular speed bias to be set expressed in radians per second
     *                    (rad/s). Must be 3x1.
     * @param mg          angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener    listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L633">        this(nedPosition, nedC, ba, ma, bg, mg);</span>
<span class="fc" id="L634">        this.listener = listener;</span>
<span class="fc" id="L635">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param ba          acceleration bias to be set expressed in meters per squared second
     *                    (m/s`2). Must be 3x1.
     * @param ma          acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg          angular speed bias to be set expressed in radians per second
     *                    (rad/s). Must be 3x1.
     * @param mg          angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg          angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L665">        this(nedPosition, nedC, ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L667">            setAngularSpeedGDependantCrossBias(gg);</span>
<span class="nc" id="L668">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L670">        }</span>
<span class="fc" id="L671">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @param ba          acceleration bias to be set expressed in meters per squared second
     *                    (m/s`2). Must be 3x1.
     * @param ma          acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg          angular speed bias to be set expressed in radians per second
     *                    (rad/s). Must be 3x1.
     * @param mg          angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg          angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener    listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L704">        this(nedPosition, nedC, ba, ma, bg, mg, gg);</span>
<span class="fc" id="L705">        this.listener = listener;</span>
<span class="fc" id="L706">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
<span class="fc" id="L720">            final CoordinateTransformation nedC) throws InvalidSourceAndDestinationFrameTypeException {</span>
        try {
<span class="fc" id="L722">            setEcefPositionAndNedOrientation(ecefPosition, nedC);</span>
<span class="nc" id="L723">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L725">        }</span>
<span class="fc" id="L726">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L743">        this(ecefPosition, nedC);</span>
<span class="fc" id="L744">        this.listener = listener;</span>
<span class="fc" id="L745">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L771">        this(ecefPosition, nedC);</span>
        try {
<span class="fc" id="L773">            setAccelerationBias(ba);</span>
<span class="fc" id="L774">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L775">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L776">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="nc" id="L777">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L779">        }</span>
<span class="fc" id="L780">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L809">        this(ecefPosition, nedC, ba, ma, bg, mg);</span>
<span class="fc" id="L810">        this.listener = listener;</span>
<span class="fc" id="L811">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L839">        this(ecefPosition, nedC);</span>
        try {
<span class="fc" id="L841">            setAccelerationBias(ba);</span>
<span class="fc" id="L842">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L843">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L844">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="fc" id="L845">            setAngularSpeedGDependantCrossBias(gg);</span>
<span class="nc" id="L846">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L848">        }</span>
<span class="fc" id="L849">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L880">        this(ecefPosition, nedC, ba, ma, bg, mg, gg);</span>
<span class="fc" id="L881">        this.listener = listener;</span>
<span class="fc" id="L882">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L908">        this(ecefPosition, nedC);</span>
        try {
<span class="fc" id="L910">            setAccelerationBias(ba);</span>
<span class="fc" id="L911">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L912">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L913">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="nc" id="L914">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L916">        }</span>
<span class="fc" id="L917">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L946">        this(ecefPosition, nedC, ba, ma, bg, mg);</span>
<span class="fc" id="L947">        this.listener = listener;</span>
<span class="fc" id="L948">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L976">        this(ecefPosition, nedC, ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L978">            setAngularSpeedGDependantCrossBias(gg);</span>
<span class="nc" id="L979">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L981">        }</span>
<span class="fc" id="L982">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1013">        this(ecefPosition, nedC, ba, ma, bg, mg, gg);</span>
<span class="fc" id="L1014">        this.listener = listener;</span>
<span class="fc" id="L1015">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition  position expressed on NED coordinates.
     * @param nedC         body to NED coordinate transformation indicating
     *                     body orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final double timeInterval) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L1044">        this(nedPosition, nedC, ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L1046">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1047">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1049">        }</span>
<span class="fc" id="L1050">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition  position expressed on NED coordinates.
     * @param nedC         body to NED coordinate transformation indicating
     *                     body orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final double timeInterval,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1082">        this(nedPosition, nedC, ba, ma, bg, mg, timeInterval);</span>
<span class="fc" id="L1083">        this.listener = listener;</span>
<span class="fc" id="L1084">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition  position expressed on NED coordinates.
     * @param nedC         body to NED coordinate transformation indicating
     *                     body orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if provided, matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final double timeInterval) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L1115">        this(nedPosition, nedC, ba, ma, bg, mg, gg);</span>
        try {
<span class="fc" id="L1117">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1118">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1120">        }</span>
<span class="fc" id="L1121">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition  position expressed on NED coordinates.
     * @param nedC         body to NED coordinate transformation indicating
     *                     body orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if provided, matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final double timeInterval,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1155">        this(nedPosition, nedC, ba, ma, bg, mg, gg, timeInterval);</span>
<span class="fc" id="L1156">        this.listener = listener;</span>
<span class="fc" id="L1157">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition  position expressed on NED coordinates.
     * @param nedC         body to NED coordinate transformation indicating
     *                     body orientation.
     * @param ba           acceleration bias to be set expressed in meters per squared second
     *                     (m/s`2). Must be 3x1.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set expressed in radians per second
     *                     (rad/s). Must be 3x1.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final double timeInterval) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L1188">        this(nedPosition, nedC, ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L1190">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1191">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1193">        }</span>
<span class="fc" id="L1194">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition  position expressed on NED coordinates.
     * @param nedC         body to NED coordinate transformation indicating
     *                     body orientation.
     * @param ba           acceleration bias to be set expressed in meters per squared second
     *                     (m/s`2). Must be 3x1.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set expressed in radians per second
     *                     (rad/s). Must be 3x1.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final double timeInterval,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1228">        this(nedPosition, nedC, ba, ma, bg, mg, timeInterval);</span>
<span class="fc" id="L1229">        this.listener = listener;</span>
<span class="fc" id="L1230">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition  position expressed on NED coordinates.
     * @param nedC         body to NED coordinate transformation indicating
     *                     body orientation.
     * @param ba           acceleration bias to be set expressed in meters per squared second
     *                     (m/s`2). Must be 3x1.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set expressed in radians per second
     *                     (rad/s). Must be 3x1.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final double timeInterval) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L1263">        this(nedPosition, nedC, ba, ma, bg, mg, gg);</span>
        try {
<span class="fc" id="L1265">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1266">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1268">        }</span>
<span class="fc" id="L1269">    }</span>

    /**
     * Constructor.
     *
     * @param nedPosition  position expressed on NED coordinates.
     * @param nedC         body to NED coordinate transformation indicating
     *                     body orientation.
     * @param ba           acceleration bias to be set expressed in meters per squared second
     *                     (m/s`2). Must be 3x1.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set expressed in radians per second
     *                     (rad/s). Must be 3x1.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final NEDPosition nedPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final double timeInterval,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1305">        this(nedPosition, nedC, ba, ma, bg, mg, gg, timeInterval);</span>
<span class="fc" id="L1306">        this.listener = listener;</span>
<span class="fc" id="L1307">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final double timeInterval) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L1336">        this(ecefPosition, nedC, ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L1338">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1339">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1341">        }</span>
<span class="fc" id="L1342">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final double timeInterval,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1374">        this(ecefPosition, nedC, ba, ma, bg, mg, timeInterval);</span>
<span class="fc" id="L1375">        this.listener = listener;</span>
<span class="fc" id="L1376">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final double timeInterval) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1408">        this(ecefPosition, nedC, ba, ma, bg, mg, gg);</span>
        try {
<span class="fc" id="L1410">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1411">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1413">        }</span>
<span class="fc" id="L1414">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final double timeInterval,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1448">        this(ecefPosition, nedC, ba, ma, bg, mg, gg, timeInterval);</span>
<span class="fc" id="L1449">        this.listener = listener;</span>
<span class="fc" id="L1450">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final double timeInterval) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L1479">        this(ecefPosition, nedC, ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L1481">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1482">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1484">        }</span>
<span class="fc" id="L1485">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final double timeInterval,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1517">        this(ecefPosition, nedC, ba, ma, bg, mg, timeInterval);</span>
<span class="fc" id="L1518">        this.listener = listener;</span>
<span class="fc" id="L1519">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final double timeInterval) throws InvalidSourceAndDestinationFrameTypeException, AlgebraException {
<span class="fc" id="L1550">        this(ecefPosition, nedC, ba, ma, bg, mg, gg);</span>
        try {
<span class="fc" id="L1552">            setTimeInterval(timeInterval);</span>
<span class="nc" id="L1553">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1555">        }</span>
<span class="fc" id="L1556">    }</span>

    /**
     * Constructor.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @param ba           acceleration bias to be set.
     * @param ma           acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg           angular speed bias to be set.
     * @param mg           angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg           angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param timeInterval time interval between body kinematics samples expressed
     *                     in seconds (s).
     * @param listener     listener to handle events.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws AlgebraException                              if provided cross-coupling matrices cannot
     *                                                       be inverted.
     * @throws IllegalArgumentException                      if any of the provided matrices are not 3x3.
     */
    public RandomWalkEstimator(
            final ECEFPosition ecefPosition,
            final CoordinateTransformation nedC,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final double timeInterval,
            final RandomWalkEstimatorListener listener) throws InvalidSourceAndDestinationFrameTypeException,
            AlgebraException {
<span class="fc" id="L1590">        this(ecefPosition, nedC, ba, ma, bg, mg, gg, timeInterval);</span>
<span class="fc" id="L1591">        this.listener = listener;</span>
<span class="fc" id="L1592">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public RandomWalkEstimatorListener getListener() {
<span class="fc" id="L1600">        return listener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if estimator is running.
     */
    public void setListener(final RandomWalkEstimatorListener listener) throws LockedException {
<span class="fc bfc" id="L1610" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1611">            throw new LockedException();</span>
        }

<span class="fc" id="L1614">        this.listener = listener;</span>
<span class="fc" id="L1615">    }</span>

    /**
     * Gets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @return bias values expressed in meters per squared second.
     */
    public Matrix getAccelerationBias() {
<span class="fc" id="L1623">        return fixer.getAccelerationBias();</span>
    }

    /**
     * Gets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBias(final Matrix result) {
<span class="fc" id="L1632">        fixer.getAccelerationBias(result);</span>
<span class="fc" id="L1633">    }</span>

    /**
     * Sets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @param bias bias values expressed in meters per squared second.
     *             Must be 3x1.
     * @throws LockedException          if estimator is running.
     * @throws IllegalArgumentException if matrix is not 3x1.
     */
    public void setAccelerationBias(final Matrix bias) throws LockedException {
<span class="fc bfc" id="L1644" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1645">            throw new LockedException();</span>
        }

<span class="fc" id="L1648">        fixer.setAccelerationBias(bias);</span>
<span class="fc" id="L1649">        driftEstimator.setAccelerationBias(bias);</span>
<span class="fc" id="L1650">    }</span>

    /**
     * Gets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @return bias values expressed in meters per squared second.
     */
    public double[] getAccelerationBiasArray() {
<span class="fc" id="L1658">        return fixer.getAccelerationBiasArray();</span>
    }

    /**
     * Gets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @param result instance where result data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAccelerationBiasArray(final double[] result) {
<span class="fc" id="L1668">        fixer.getAccelerationBiasArray(result);</span>
<span class="fc" id="L1669">    }</span>

    /**
     * Sets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @param bias bias values expressed in meters per squared second (m/s^2).
     *             Must have length 3.
     * @throws IllegalArgumentException if provided array does not have length 3.
     * @throws LockedException          if estimator is running.
     */
    public void setAccelerationBias(final double[] bias) throws LockedException {
<span class="fc bfc" id="L1680" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1681">            throw new LockedException();</span>
        }

<span class="fc" id="L1684">        fixer.setAccelerationBias(bias);</span>
<span class="fc" id="L1685">        driftEstimator.setAccelerationBias(bias);</span>
<span class="fc" id="L1686">    }</span>

    /**
     * Gets acceleration bias.
     *
     * @return acceleration bias.
     */
    public AccelerationTriad getAccelerationBiasAsTriad() {
<span class="fc" id="L1694">        return fixer.getAccelerationBiasAsTriad();</span>
    }

    /**
     * Gets acceleration bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBiasAsTriad(final AccelerationTriad result) {
<span class="fc" id="L1703">        fixer.getAccelerationBiasAsTriad(result);</span>
<span class="fc" id="L1704">    }</span>

    /**
     * Sets acceleration bias.
     *
     * @param bias acceleration bias to be set.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBias(final AccelerationTriad bias) throws LockedException {
<span class="fc bfc" id="L1713" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1714">            throw new LockedException();</span>
        }

<span class="fc" id="L1717">        fixer.setAccelerationBias(bias);</span>
<span class="fc" id="L1718">        driftEstimator.setAccelerationBias(bias);</span>
<span class="fc" id="L1719">    }</span>

    /**
     * Gets acceleration x-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return x-coordinate of bias expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasX() {
<span class="fc" id="L1728">        return fixer.getAccelerationBiasX();</span>
    }

    /**
     * Sets acceleration x-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasX x-coordinate of bias expressed in meters per squared second
     *              (m/s^2).
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasX(final double biasX) throws LockedException {
<span class="fc bfc" id="L1740" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1741">            throw new LockedException();</span>
        }

<span class="fc" id="L1744">        fixer.setAccelerationBiasX(biasX);</span>
<span class="fc" id="L1745">        driftEstimator.setAccelerationBiasX(biasX);</span>
<span class="fc" id="L1746">    }</span>

    /**
     * Gets acceleration y-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return y-coordinate of bias expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasY() {
<span class="fc" id="L1755">        return fixer.getAccelerationBiasY();</span>
    }

    /**
     * Sets acceleration y-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasY y-coordinate of bias expressed in meters per squared second
     *              (m/s^2).
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasY(final double biasY) throws LockedException {
<span class="fc bfc" id="L1767" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1768">            throw new LockedException();</span>
        }

<span class="fc" id="L1771">        fixer.setAccelerationBiasY(biasY);</span>
<span class="fc" id="L1772">        driftEstimator.setAccelerationBiasY(biasY);</span>
<span class="fc" id="L1773">    }</span>

    /**
     * Gets acceleration z-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return z-coordinate of bias expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasZ() {
<span class="fc" id="L1782">        return fixer.getAccelerationBiasZ();</span>
    }

    /**
     * Sets acceleration z-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasZ z-coordinate of bias expressed in meters per squared second (m/s^2).
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasZ(final double biasZ) throws LockedException {
<span class="fc bfc" id="L1793" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1794">            throw new LockedException();</span>
        }

<span class="fc" id="L1797">        fixer.setAccelerationBiasZ(biasZ);</span>
<span class="fc" id="L1798">        driftEstimator.setAccelerationBiasZ(biasZ);</span>
<span class="fc" id="L1799">    }</span>

    /**
     * Sets acceleration coordinates of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBias(
            final double biasX, final double biasY, final double biasZ) throws LockedException {
<span class="fc bfc" id="L1812" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1813">            throw new LockedException();</span>
        }

<span class="fc" id="L1816">        fixer.setAccelerationBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L1817">        driftEstimator.setAccelerationBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L1818">    }</span>

    /**
     * Gets acceleration x-coordinate of bias.
     *
     * @return acceleration x-coordinate of bias.
     */
    public Acceleration getAccelerationBiasXAsAcceleration() {
<span class="fc" id="L1826">        return fixer.getAccelerationBiasXAsAcceleration();</span>
    }

    /**
     * Gets acceleration x-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBiasXAsAcceleration(final Acceleration result) {
<span class="fc" id="L1835">        fixer.getAccelerationBiasXAsAcceleration(result);</span>
<span class="fc" id="L1836">    }</span>

    /**
     * Sets acceleration x-coordinate of bias.
     *
     * @param biasX acceleration x-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasX(final Acceleration biasX) throws LockedException {
<span class="fc bfc" id="L1845" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1846">            throw new LockedException();</span>
        }

<span class="fc" id="L1849">        fixer.setAccelerationBiasX(biasX);</span>
<span class="fc" id="L1850">        driftEstimator.setAccelerationBiasX(biasX);</span>
<span class="fc" id="L1851">    }</span>

    /**
     * Gets acceleration y-coordinate of bias.
     *
     * @return acceleration y-coordinate of bias.
     */
    public Acceleration getAccelerationBiasYAsAcceleration() {
<span class="fc" id="L1859">        return fixer.getAccelerationBiasYAsAcceleration();</span>
    }

    /**
     * Gets acceleration y-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBiasYAsAcceleration(final Acceleration result) {
<span class="fc" id="L1868">        fixer.getAccelerationBiasYAsAcceleration(result);</span>
<span class="fc" id="L1869">    }</span>

    /**
     * Sets acceleration y-coordinate of bias.
     *
     * @param biasY acceleration y-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasY(final Acceleration biasY) throws LockedException {
<span class="fc bfc" id="L1878" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1879">            throw new LockedException();</span>
        }

<span class="fc" id="L1882">        fixer.setAccelerationBiasY(biasY);</span>
<span class="fc" id="L1883">        driftEstimator.setAccelerationBiasY(biasY);</span>
<span class="fc" id="L1884">    }</span>

    /**
     * Gets acceleration z-coordinate of bias.
     *
     * @return acceleration z-coordinate of bias.
     */
    public Acceleration getAccelerationBiasZAsAcceleration() {
<span class="fc" id="L1892">        return fixer.getAccelerationBiasZAsAcceleration();</span>
    }

    /**
     * Gets acceleration z-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBiasZAsAcceleration(final Acceleration result) {
<span class="fc" id="L1901">        fixer.getAccelerationBiasZAsAcceleration(result);</span>
<span class="fc" id="L1902">    }</span>

    /**
     * Sets acceleration z-coordinate of bias.
     *
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasZ(final Acceleration biasZ) throws LockedException {
<span class="fc bfc" id="L1911" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1912">            throw new LockedException();</span>
        }

<span class="fc" id="L1915">        fixer.setAccelerationBiasZ(biasZ);</span>
<span class="fc" id="L1916">        driftEstimator.setAccelerationBiasZ(biasZ);</span>
<span class="fc" id="L1917">    }</span>

    /**
     * Sets acceleration coordinates of bias.
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBias(
            final Acceleration biasX,
            final Acceleration biasY,
            final Acceleration biasZ) throws LockedException {
<span class="fc bfc" id="L1931" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1932">            throw new LockedException();</span>
        }

<span class="fc" id="L1935">        fixer.setAccelerationBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L1936">        driftEstimator.setAccelerationBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L1937">    }</span>

    /**
     * Gets acceleration cross-coupling errors matrix.
     *
     * @return acceleration cross-coupling errors matrix.
     */
    public Matrix getAccelerationCrossCouplingErrors() {
<span class="fc" id="L1945">        return fixer.getAccelerationCrossCouplingErrors();</span>
    }

    /**
     * Gets acceleration cross-coupling errors matrix.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L1954">        fixer.getAccelerationCrossCouplingErrors(result);</span>
<span class="fc" id="L1955">    }</span>

    /**
     * Sets acceleration cross-coupling errors matrix.
     *
     * @param crossCouplingErrors acceleration cross-coupling errors matrix.
     *                            Must be 3x3.
     * @throws LockedException          if estimator is running.
     * @throws AlgebraException         if matrix cannot be inverted.
     * @throws IllegalArgumentException if matrix is not 3x3.
     */
    public void setAccelerationCrossCouplingErrors(final Matrix crossCouplingErrors) throws AlgebraException,
            LockedException {
<span class="fc bfc" id="L1968" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1969">            throw new LockedException();</span>
        }

<span class="fc" id="L1972">        fixer.setAccelerationCrossCouplingErrors(crossCouplingErrors);</span>
<span class="fc" id="L1973">        driftEstimator.setAccelerationCrossCouplingErrors(crossCouplingErrors);</span>
<span class="fc" id="L1974">    }</span>

    /**
     * Gets acceleration x scaling factor.
     *
     * @return x scaling factor.
     */
    public double getAccelerationSx() {
<span class="fc" id="L1982">        return fixer.getAccelerationSx();</span>
    }

    /**
     * Sets acceleration x scaling factor.
     *
     * @param sx x scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationSx(final double sx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1993" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1994">            throw new LockedException();</span>
        }

<span class="fc" id="L1997">        fixer.setAccelerationSx(sx);</span>
<span class="fc" id="L1998">        driftEstimator.setAccelerationSx(sx);</span>
<span class="fc" id="L1999">    }</span>

    /**
     * Gets acceleration y scaling factor.
     *
     * @return y scaling factor.
     */
    public double getAccelerationSy() {
<span class="fc" id="L2007">        return fixer.getAccelerationSy();</span>
    }

    /**
     * Sets acceleration y scaling factor.
     *
     * @param sy y scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationSy(final double sy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2018" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2019">            throw new LockedException();</span>
        }

<span class="fc" id="L2022">        fixer.setAccelerationSy(sy);</span>
<span class="fc" id="L2023">        driftEstimator.setAccelerationSy(sy);</span>
<span class="fc" id="L2024">    }</span>

    /**
     * Gets acceleration z scaling factor.
     *
     * @return z scaling factor.
     */
    public double getAccelerationSz() {
<span class="fc" id="L2032">        return fixer.getAccelerationSz();</span>
    }

    /**
     * Sets acceleration z scaling factor.
     *
     * @param sz z scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationSz(final double sz) throws LockedException, AlgebraException {
<span class="pc bpc" id="L2043" title="1 of 2 branches missed.">        if (running) {</span>
<span class="nc" id="L2044">            throw new LockedException();</span>
        }

<span class="fc" id="L2047">        fixer.setAccelerationSz(sz);</span>
<span class="fc" id="L2048">        driftEstimator.setAccelerationSz(sz);</span>
<span class="fc" id="L2049">    }</span>

    /**
     * Gets acceleration x-y cross-coupling error.
     *
     * @return acceleration x-y cross-coupling error.
     */
    public double getAccelerationMxy() {
<span class="fc" id="L2057">        return fixer.getAccelerationMxy();</span>
    }

    /**
     * Sets acceleration x-y cross-coupling error.
     *
     * @param mxy acceleration x-y cross-coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMxy(final double mxy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2068" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2069">            throw new LockedException();</span>
        }

<span class="fc" id="L2072">        fixer.setAccelerationMxy(mxy);</span>
<span class="fc" id="L2073">        driftEstimator.setAccelerationMxy(mxy);</span>
<span class="fc" id="L2074">    }</span>

    /**
     * Gets acceleration x-z cross-coupling error.
     *
     * @return acceleration x-z cross-coupling error.
     */
    public double getAccelerationMxz() {
<span class="fc" id="L2082">        return fixer.getAccelerationMxz();</span>
    }

    /**
     * Sets acceleration x-z cross-coupling error.
     *
     * @param mxz acceleration x-z cross-coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMxz(final double mxz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2093" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2094">            throw new LockedException();</span>
        }

<span class="fc" id="L2097">        fixer.setAccelerationMxz(mxz);</span>
<span class="fc" id="L2098">        driftEstimator.setAccelerationMxz(mxz);</span>
<span class="fc" id="L2099">    }</span>

    /**
     * Gets acceleration y-x cross-coupling error.
     *
     * @return acceleration y-x cross-coupling error.
     */
    public double getAccelerationMyx() {
<span class="fc" id="L2107">        return fixer.getAccelerationMyx();</span>
    }

    /**
     * Sets acceleration y-x cross-coupling error.
     *
     * @param myx acceleration y-x cross-coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMyx(final double myx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2118" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2119">            throw new LockedException();</span>
        }

<span class="fc" id="L2122">        fixer.setAccelerationMyx(myx);</span>
<span class="fc" id="L2123">        driftEstimator.setAccelerationMyx(myx);</span>
<span class="fc" id="L2124">    }</span>

    /**
     * Gets acceleration y-z cross-coupling error.
     *
     * @return y-z cross coupling error.
     */
    public double getAccelerationMyz() {
<span class="fc" id="L2132">        return fixer.getAccelerationMyz();</span>
    }

    /**
     * Sets acceleration y-z cross-coupling error.
     *
     * @param myz y-z cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMyz(final double myz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2143" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2144">            throw new LockedException();</span>
        }

<span class="fc" id="L2147">        fixer.setAccelerationMyz(myz);</span>
<span class="fc" id="L2148">        driftEstimator.setAccelerationMyz(myz);</span>
<span class="fc" id="L2149">    }</span>

    /**
     * Gets acceleration z-x cross-coupling error.
     *
     * @return acceleration z-x cross-coupling error.
     */
    public double getAccelerationMzx() {
<span class="fc" id="L2157">        return fixer.getAccelerationMzx();</span>
    }

    /**
     * Sets acceleration z-x cross-coupling error.
     *
     * @param mzx acceleration z-x cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMzx(final double mzx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2168" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2169">            throw new LockedException();</span>
        }

<span class="fc" id="L2172">        fixer.setAccelerationMzx(mzx);</span>
<span class="fc" id="L2173">        driftEstimator.setAccelerationMzx(mzx);</span>
<span class="fc" id="L2174">    }</span>

    /**
     * Gets acceleration z-y cross-coupling error.
     *
     * @return acceleration z-y cross-coupling error.
     */
    public double getAccelerationMzy() {
<span class="fc" id="L2182">        return fixer.getAccelerationMzy();</span>
    }

    /**
     * Sets acceleration z-y cross-coupling error.
     *
     * @param mzy acceleration z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMzy(final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2193" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2194">            throw new LockedException();</span>
        }

<span class="fc" id="L2197">        fixer.setAccelerationMzy(mzy);</span>
<span class="fc" id="L2198">        driftEstimator.setAccelerationMzy(mzy);</span>
<span class="fc" id="L2199">    }</span>

    /**
     * Sets acceleration scaling factors.
     *
     * @param sx x scaling factor.
     * @param sy y scaling factor.
     * @param sz z scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationScalingFactors(final double sx, final double sy, final double sz) throws LockedException,
            AlgebraException {
<span class="fc bfc" id="L2212" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2213">            throw new LockedException();</span>
        }

<span class="fc" id="L2216">        fixer.setAccelerationScalingFactors(sx, sy, sz);</span>
<span class="fc" id="L2217">        driftEstimator.setAccelerationScalingFactors(sx, sy, sz);</span>
<span class="fc" id="L2218">    }</span>

    /**
     * Sets acceleration cross-coupling errors.
     *
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationCrossCouplingErrors(
            final double mxy, final double mxz,
            final double myx, final double myz,
            final double mzx, final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2236" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2237">            throw new LockedException();</span>
        }

<span class="fc" id="L2240">        fixer.setAccelerationCrossCouplingErrors(mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2241">        driftEstimator.setAccelerationCrossCouplingErrors(mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2242">    }</span>

    /**
     * Sets acceleration scaling factors and cross-coupling errors.
     *
     * @param sx  x scaling factor.
     * @param sy  y scaling factor.
     * @param sz  z scaling factor.
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationScalingFactorsAndCrossCouplingErrors(
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz,
            final double myx, final double myz,
            final double mzx, final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2264" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2265">            throw new LockedException();</span>
        }

<span class="fc" id="L2268">        fixer.setAccelerationScalingFactorsAndCrossCouplingErrors(sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2269">        driftEstimator.setAccelerationScalingFactorsAndCrossCouplingErrors(sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2270">    }</span>

    /**
     * Gets angular speed bias values expressed in radians per second (rad/s).
     *
     * @return angular speed bias values expressed in radians per second.
     */
    public Matrix getAngularSpeedBias() {
<span class="fc" id="L2278">        return fixer.getAngularSpeedBias();</span>
    }

    /**
     * Gets angular speed bias values expressed in radians per second (rad/s).
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBias(final Matrix result) {
<span class="fc" id="L2287">        fixer.getAngularSpeedBias(result);</span>
<span class="fc" id="L2288">    }</span>

    /**
     * Sets angular speed bias values expressed in radians per second (rad/s).
     *
     * @param bias bias values expressed in radians per second. Must be 3x1.
     * @throws IllegalArgumentException if matrix is not 3x1.
     * @throws LockedException          if estimator is running.
     */
    public void setAngularSpeedBias(final Matrix bias) throws LockedException {
<span class="fc bfc" id="L2298" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2299">            throw new LockedException();</span>
        }

<span class="fc" id="L2302">        fixer.setAngularSpeedBias(bias);</span>
<span class="fc" id="L2303">        driftEstimator.setAngularSpeedBias(bias);</span>
<span class="fc" id="L2304">    }</span>

    /**
     * Gets angular speed bias values expressed in radians per second (rad/s).
     *
     * @return bias values expressed in radians per second.
     */
    public double[] getAngularSpeedBiasArray() {
<span class="fc" id="L2312">        return fixer.getAngularSpeedBiasArray();</span>
    }

    /**
     * Gets angular speed bias values expressed in radians per second (rad/s).
     *
     * @param result instance where result data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAngularSpeedBiasArray(final double[] result) {
<span class="fc" id="L2322">        fixer.getAngularSpeedBiasArray(result);</span>
<span class="fc" id="L2323">    }</span>

    /**
     * Sets angular speed bias values expressed in radians per second (rad/s).
     *
     * @param bias bias values expressed in radians per second (rad/s). Must
     *             have length 3.
     * @throws IllegalArgumentException if provided array does not have length 3.
     * @throws LockedException          if estimator is running.
     */
    public void setAngularSpeedBias(final double[] bias) throws LockedException {
<span class="fc bfc" id="L2334" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2335">            throw new LockedException();</span>
        }

<span class="fc" id="L2338">        fixer.setAngularSpeedBias(bias);</span>
<span class="fc" id="L2339">        driftEstimator.setAngularSpeedBias(bias);</span>
<span class="fc" id="L2340">    }</span>

    /**
     * Gets angular speed bias.
     *
     * @return angular speed bias.
     */
    public AngularSpeedTriad getAngularSpeedBiasAsTriad() {
<span class="fc" id="L2348">        return fixer.getAngularSpeedBiasAsTriad();</span>
    }

    /**
     * Gets angular speed bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBiasAsTriad(final AngularSpeedTriad result) {
<span class="fc" id="L2357">        fixer.getAngularSpeedBiasAsTriad(result);</span>
<span class="fc" id="L2358">    }</span>

    /**
     * Sets angular speed bias.
     *
     * @param bias angular speed bias to be set.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBias(final AngularSpeedTriad bias) throws LockedException {
<span class="fc bfc" id="L2367" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2368">            throw new LockedException();</span>
        }

<span class="fc" id="L2371">        fixer.setAngularSpeedBias(bias);</span>
<span class="fc" id="L2372">        driftEstimator.setAngularSpeedBias(bias);</span>
<span class="fc" id="L2373">    }</span>

    /**
     * Gets angular speed x-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @return x-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getAngularSpeedBiasX() {
<span class="fc" id="L2382">        return fixer.getAngularSpeedBiasX();</span>
    }

    /**
     * Sets angular speed x-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @param biasX x-coordinate of bias expressed in radians per second (rad/s).
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasX(final double biasX) throws LockedException {
<span class="fc bfc" id="L2393" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2394">            throw new LockedException();</span>
        }

<span class="fc" id="L2397">        fixer.setAngularSpeedBiasX(biasX);</span>
<span class="fc" id="L2398">        driftEstimator.setAngularSpeedBiasX(biasX);</span>
<span class="fc" id="L2399">    }</span>

    /**
     * Gets angular speed y-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @return y-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getAngularSpeedBiasY() {
<span class="fc" id="L2408">        return fixer.getAngularSpeedBiasY();</span>
    }

    /**
     * Sets angular speed y-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @param biasY y-coordinate of bias expressed in radians per second (rad/s).
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasY(final double biasY) throws LockedException {
<span class="fc bfc" id="L2419" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2420">            throw new LockedException();</span>
        }

<span class="fc" id="L2423">        fixer.setAngularSpeedBiasY(biasY);</span>
<span class="fc" id="L2424">        driftEstimator.setAngularSpeedBiasY(biasY);</span>
<span class="fc" id="L2425">    }</span>

    /**
     * Gets angular speed z-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @return z-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getAngularSpeedBiasZ() {
<span class="fc" id="L2434">        return fixer.getAngularSpeedBiasZ();</span>
    }

    /**
     * Sets angular speed z-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @param biasZ z-coordinate of bias expressed in radians per second (rad/s).
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasZ(final double biasZ) throws LockedException {
<span class="fc bfc" id="L2445" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2446">            throw new LockedException();</span>
        }

<span class="fc" id="L2449">        fixer.setAngularSpeedBiasZ(biasZ);</span>
<span class="fc" id="L2450">        driftEstimator.setAngularSpeedBiasZ(biasZ);</span>
<span class="fc" id="L2451">    }</span>

    /**
     * Sets angular speed coordinates of bias expressed in radians per second
     * (rad/s).
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBias(final double biasX, final double biasY, final double biasZ) throws LockedException {
<span class="fc bfc" id="L2463" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2464">            throw new LockedException();</span>
        }

<span class="fc" id="L2467">        fixer.setAngularSpeedBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L2468">        driftEstimator.setAngularSpeedBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L2469">    }</span>

    /**
     * Gets angular speed x-coordinate of bias.
     *
     * @return x-coordinate of bias.
     */
    public AngularSpeed getAngularSpeedBiasXAsAngularSpeed() {
<span class="fc" id="L2477">        return fixer.getAngularSpeedBiasXAsAngularSpeed();</span>
    }

    /**
     * Gets angular speed x-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBiasXAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2486">        fixer.getAngularSpeedBiasXAsAngularSpeed(result);</span>
<span class="fc" id="L2487">    }</span>

    /**
     * Sets angular speed x-coordinate of bias.
     *
     * @param biasX x-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasX(final AngularSpeed biasX) throws LockedException {
<span class="fc bfc" id="L2496" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2497">            throw new LockedException();</span>
        }

<span class="fc" id="L2500">        fixer.setAngularSpeedBiasX(biasX);</span>
<span class="fc" id="L2501">        driftEstimator.setAngularSpeedBiasX(biasX);</span>
<span class="fc" id="L2502">    }</span>

    /**
     * Gets angular speed y-coordinate of bias.
     *
     * @return y-coordinate of bias.
     */
    public AngularSpeed getAngularSpeedBiasYAsAngularSpeed() {
<span class="fc" id="L2510">        return fixer.getAngularSpeedBiasYAsAngularSpeed();</span>
    }

    /**
     * Gets angular speed y-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBiasYAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2519">        fixer.getAngularSpeedBiasYAsAngularSpeed(result);</span>
<span class="fc" id="L2520">    }</span>

    /**
     * Sets angular speed y-coordinate of bias.
     *
     * @param biasY y-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasY(final AngularSpeed biasY) throws LockedException {
<span class="fc bfc" id="L2529" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2530">            throw new LockedException();</span>
        }

<span class="fc" id="L2533">        fixer.setAngularSpeedBiasY(biasY);</span>
<span class="fc" id="L2534">        driftEstimator.setAngularSpeedBiasY(biasY);</span>
<span class="fc" id="L2535">    }</span>

    /**
     * Gets angular speed z-coordinate of bias.
     *
     * @return z-coordinate of bias.
     */
    public AngularSpeed getAngularSpeedBiasZAsAngularSpeed() {
<span class="fc" id="L2543">        return fixer.getAngularSpeedBiasZAsAngularSpeed();</span>
    }

    /**
     * Gets angular speed z-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBiasZAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2552">        fixer.getAngularSpeedBiasZAsAngularSpeed(result);</span>
<span class="fc" id="L2553">    }</span>

    /**
     * Sets angular speed z-coordinate of bias.
     *
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasZ(final AngularSpeed biasZ) throws LockedException {
<span class="fc bfc" id="L2562" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2563">            throw new LockedException();</span>
        }

<span class="fc" id="L2566">        fixer.setAngularSpeedBiasZ(biasZ);</span>
<span class="fc" id="L2567">        driftEstimator.setAngularSpeedBiasZ(biasZ);</span>
<span class="fc" id="L2568">    }</span>

    /**
     * Sets angular speed coordinates of bias.
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBias(
            final AngularSpeed biasX,
            final AngularSpeed biasY,
            final AngularSpeed biasZ) throws LockedException {
<span class="fc bfc" id="L2582" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2583">            throw new LockedException();</span>
        }

<span class="fc" id="L2586">        fixer.setAngularSpeedBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L2587">        driftEstimator.setAngularSpeedBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L2588">    }</span>

    /**
     * Gets angular speed cross-coupling errors matrix.
     *
     * @return cross coupling errors matrix.
     */
    public Matrix getAngularSpeedCrossCouplingErrors() {
<span class="fc" id="L2596">        return fixer.getAngularSpeedCrossCouplingErrors();</span>
    }

    /**
     * Gets angular speed cross-coupling errors matrix.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L2605">        fixer.getAngularSpeedCrossCouplingErrors(result);</span>
<span class="fc" id="L2606">    }</span>

    /**
     * Sets angular speed cross-coupling errors matrix.
     *
     * @param crossCouplingErrors cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if matrix cannot be inverted.
     * @throws IllegalArgumentException if matrix is not 3x3.
     * @throws LockedException          if estimator is running.
     */
    public void setAngularSpeedCrossCouplingErrors(final Matrix crossCouplingErrors) throws AlgebraException,
            LockedException {
<span class="fc bfc" id="L2618" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2619">            throw new LockedException();</span>
        }

<span class="fc" id="L2622">        fixer.setAngularSpeedCrossCouplingErrors(crossCouplingErrors);</span>
<span class="fc" id="L2623">        driftEstimator.setAngularSpeedCrossCouplingErrors(crossCouplingErrors);</span>
<span class="fc" id="L2624">    }</span>

    /**
     * Gets angular speed x scaling factor.
     *
     * @return x scaling factor.
     */
    public double getAngularSpeedSx() {
<span class="fc" id="L2632">        return fixer.getAngularSpeedSx();</span>
    }

    /**
     * Sets angular speed x scaling factor.
     *
     * @param sx x scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed-cross coupling matrix non-invertible.
     */
    public void setAngularSpeedSx(final double sx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2643" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2644">            throw new LockedException();</span>
        }

<span class="fc" id="L2647">        fixer.setAngularSpeedSx(sx);</span>
<span class="fc" id="L2648">        driftEstimator.setAngularSpeedSx(sx);</span>
<span class="fc" id="L2649">    }</span>

    /**
     * Gets angular speed y scaling factor.
     *
     * @return y scaling factor.
     */
    public double getAngularSpeedSy() {
<span class="fc" id="L2657">        return fixer.getAngularSpeedSy();</span>
    }

    /**
     * Sets angular speed y-scaling factor.
     *
     * @param sy y scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedSy(final double sy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2669" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2670">            throw new LockedException();</span>
        }

<span class="fc" id="L2673">        fixer.setAngularSpeedSy(sy);</span>
<span class="fc" id="L2674">        driftEstimator.setAngularSpeedSy(sy);</span>
<span class="fc" id="L2675">    }</span>

    /**
     * Gets angular speed z scaling factor.
     *
     * @return z scaling factor.
     */
    public double getAngularSpeedSz() {
<span class="fc" id="L2683">        return fixer.getAngularSpeedSz();</span>
    }

    /**
     * Sets angular speed z scaling factor.
     *
     * @param sz z scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedSz(final double sz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2695" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2696">            throw new LockedException();</span>
        }

<span class="fc" id="L2699">        fixer.setAngularSpeedSz(sz);</span>
<span class="fc" id="L2700">        driftEstimator.setAngularSpeedSz(sz);</span>
<span class="fc" id="L2701">    }</span>

    /**
     * Gets angular speed x-y cross-coupling error.
     *
     * @return x-y cross coupling error.
     */
    public double getAngularSpeedMxy() {
<span class="fc" id="L2709">        return fixer.getAngularSpeedMxy();</span>
    }

    /**
     * Sets angular speed x-y cross-coupling error.
     *
     * @param mxy x-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMxy(final double mxy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2721" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2722">            throw new LockedException();</span>
        }

<span class="fc" id="L2725">        fixer.setAngularSpeedMxy(mxy);</span>
<span class="fc" id="L2726">        driftEstimator.setAngularSpeedMxy(mxy);</span>
<span class="fc" id="L2727">    }</span>

    /**
     * Gets angular speed x-z cross-coupling error.
     *
     * @return x-z cross coupling error.
     */
    public double getAngularSpeedMxz() {
<span class="fc" id="L2735">        return fixer.getAngularSpeedMxz();</span>
    }

    /**
     * Sets angular speed x-z cross-coupling error.
     *
     * @param mxz x-z cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMxz(final double mxz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2747" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2748">            throw new LockedException();</span>
        }

<span class="fc" id="L2751">        fixer.setAngularSpeedMxz(mxz);</span>
<span class="fc" id="L2752">        driftEstimator.setAngularSpeedMxz(mxz);</span>
<span class="fc" id="L2753">    }</span>

    /**
     * Gets angular speed y-x cross-coupling error.
     *
     * @return y-x cross coupling error.
     */
    public double getAngularSpeedMyx() {
<span class="fc" id="L2761">        return fixer.getAngularSpeedMyx();</span>
    }

    /**
     * Sets angular speed y-x cross-coupling error.
     *
     * @param myx y-x cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMyx(final double myx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2773" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2774">            throw new LockedException();</span>
        }

<span class="fc" id="L2777">        fixer.setAngularSpeedMyx(myx);</span>
<span class="fc" id="L2778">        driftEstimator.setAngularSpeedMyx(myx);</span>
<span class="fc" id="L2779">    }</span>

    /**
     * Gets angular speed y-z cross-coupling error.
     *
     * @return y-z cross coupling error.
     */
    public double getAngularSpeedMyz() {
<span class="fc" id="L2787">        return fixer.getAngularSpeedMyz();</span>
    }

    /**
     * Sets angular speed y-z cross-coupling error.
     *
     * @param myz y-z cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMyz(final double myz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2799" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2800">            throw new LockedException();</span>
        }

<span class="fc" id="L2803">        fixer.setAngularSpeedMyz(myz);</span>
<span class="fc" id="L2804">        driftEstimator.setAngularSpeedMyz(myz);</span>
<span class="fc" id="L2805">    }</span>

    /**
     * Gets angular speed z-x cross-coupling error.
     *
     * @return z-x cross coupling error.
     */
    public double getAngularSpeedMzx() {
<span class="fc" id="L2813">        return fixer.getAngularSpeedMzx();</span>
    }

    /**
     * Sets angular speed z-x cross-coupling error.
     *
     * @param mzx z-x cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMzx(final double mzx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2825" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2826">            throw new LockedException();</span>
        }

<span class="fc" id="L2829">        fixer.setAngularSpeedMzx(mzx);</span>
<span class="fc" id="L2830">        driftEstimator.setAngularSpeedMzx(mzx);</span>
<span class="fc" id="L2831">    }</span>

    /**
     * Gets angular speed z-y cross-coupling error.
     *
     * @return z-y cross coupling error.
     */
    public double getAngularSpeedMzy() {
<span class="fc" id="L2839">        return fixer.getAngularSpeedMzy();</span>
    }

    /**
     * Sets angular speed z-y cross-coupling error.
     *
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMzy(final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2851" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2852">            throw new LockedException();</span>
        }

<span class="fc" id="L2855">        fixer.setAngularSpeedMzy(mzy);</span>
<span class="fc" id="L2856">        driftEstimator.setAngularSpeedMzy(mzy);</span>
<span class="fc" id="L2857">    }</span>

    /**
     * Sets angular speed scaling factors.
     *
     * @param sx x scaling factor.
     * @param sy y scaling factor.
     * @param sz z scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedScalingFactors(final double sx, final double sy, final double sz) throws LockedException,
            AlgebraException {
<span class="fc bfc" id="L2871" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2872">            throw new LockedException();</span>
        }

<span class="fc" id="L2875">        fixer.setAngularSpeedScalingFactors(sx, sy, sz);</span>
<span class="fc" id="L2876">        driftEstimator.setAngularSpeedScalingFactors(sx, sy, sz);</span>
<span class="fc" id="L2877">    }</span>

    /**
     * Sets angular speed cross-coupling errors.
     *
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedCrossCouplingErrors(
            final double mxy, final double mxz,
            final double myx, final double myz,
            final double mzx, final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2896" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2897">            throw new LockedException();</span>
        }

<span class="fc" id="L2900">        fixer.setAngularSpeedCrossCouplingErrors(mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2901">        driftEstimator.setAngularSpeedCrossCouplingErrors(mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2902">    }</span>

    /**
     * Sets angular speed scaling factors and cross-coupling errors.
     *
     * @param sx  x scaling factor.
     * @param sy  y scaling factor.
     * @param sz  z scaling factor.
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedScalingFactorsAndCrossCouplingErrors(
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz,
            final double myx, final double myz,
            final double mzx, final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2925" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2926">            throw new LockedException();</span>
        }

<span class="fc" id="L2929">        fixer.setAngularSpeedScalingFactorsAndCrossCouplingErrors(sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2930">        driftEstimator.setAngularSpeedScalingFactorsAndCrossCouplingErrors(sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2931">    }</span>

    /**
     * Gets angular speed g-dependant cross biases matrix.
     *
     * @return g-dependant cross biases matrix.
     */
    public Matrix getAngularSpeedGDependantCrossBias() {
<span class="fc" id="L2939">        return fixer.getAngularSpeedGDependantCrossBias();</span>
    }

    /**
     * Gets angular speed g-dependant cross biases matrix.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedGDependantCrossBias(final Matrix result) {
<span class="fc" id="L2948">        fixer.getAngularSpeedGDependantCrossBias(result);</span>
<span class="fc" id="L2949">    }</span>

    /**
     * Sets angular speed g-dependant cross biases matrix.
     *
     * @param gDependantCrossBias g-dependant cross biases matrix.
     * @throws IllegalArgumentException if provided, matrix is not 3x3.
     * @throws LockedException          if estimator is running.
     */
    public void setAngularSpeedGDependantCrossBias(final Matrix gDependantCrossBias) throws LockedException {
<span class="fc bfc" id="L2959" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2960">            throw new LockedException();</span>
        }

<span class="fc" id="L2963">        fixer.setAngularSpeedGDependantCrossBias(gDependantCrossBias);</span>
<span class="fc" id="L2964">        driftEstimator.setAngularSpeedGDependantCrossBias(gDependantCrossBias);</span>
<span class="fc" id="L2965">    }</span>

    /**
     * Gets the time interval between body kinematics (IMU acceleration and gyroscope)
     * samples expressed in seconds (s).
     *
     * @return time interval between body kinematics samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L2974">        return biasEstimator.getTimeInterval();</span>
    }

    /**
     * Sets a time interval between body kinematics (IMU acceleration and gyroscope)
     * samples expressed in seconds (s).
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L2985" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2986">            throw new LockedException();</span>
        }

<span class="fc" id="L2989">        biasEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L2990">        driftEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L2991">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration and gyroscope)
     * samples.
     *
     * @return time interval between body kinematics samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L3000">        return biasEstimator.getTimeIntervalAsTime();</span>
    }

    /**
     * Gets time interval between body kinematics (IMU acceleration and gyroscope)
     * samples.
     *
     * @param result instance where the time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L3010">        biasEstimator.getTimeIntervalAsTime(result);</span>
<span class="fc" id="L3011">    }</span>

    /**
     * Sets time interval between body kinematics (IMU acceleration and gyroscope)
     * samples.
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc bfc" id="L3021" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3022">            throw new LockedException();</span>
        }

<span class="fc" id="L3025">        biasEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L3026">        driftEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L3027">    }</span>

    /**
     * Gets current body position expressed in ECEF coordinates.
     *
     * @return current body position expressed in ECEF coordinates.
     */
    public ECEFPosition getEcefPosition() {
<span class="fc" id="L3035">        return biasEstimator.getEcefPosition();</span>
    }

    /**
     * Gets current body position expressed in ECEF coordinates.
     *
     * @param result instance where current body position will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
<span class="fc" id="L3044">        biasEstimator.getEcefPosition(result);</span>
<span class="fc" id="L3045">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param position current body position to be set.
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final ECEFPosition position) throws LockedException {
<span class="fc bfc" id="L3054" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3055">            throw new LockedException();</span>
        }

<span class="fc" id="L3058">        biasEstimator.setEcefPosition(position);</span>
<span class="fc" id="L3059">        driftEstimator.setReferenceEcefPosition(position);</span>
<span class="fc" id="L3060">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param x x position resolved around ECEF axes and expressed in meters (m).
     * @param y y position resolved around ECEF axes and expressed in meters (m).
     * @param z z position resolved around ECEF axes and expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final double x, final double y, final double z) throws LockedException {
<span class="fc bfc" id="L3071" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3072">            throw new LockedException();</span>
        }

<span class="fc" id="L3075">        biasEstimator.setEcefPosition(x, y, z);</span>
<span class="fc" id="L3076">        driftEstimator.setReferenceEcefPosition(biasEstimator.getEcefPosition());</span>
<span class="fc" id="L3077">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param x x position resolved around ECEF axes.
     * @param y y position resolved around ECEF axes.
     * @param z z position resolved around ECEF axes.
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final Distance x, final Distance y, final Distance z) throws LockedException {
<span class="fc bfc" id="L3088" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3089">            throw new LockedException();</span>
        }

<span class="fc" id="L3092">        biasEstimator.setEcefPosition(x, y, z);</span>
<span class="fc" id="L3093">        driftEstimator.setReferenceEcefPosition(biasEstimator.getEcefPosition());</span>
<span class="fc" id="L3094">    }</span>

    /**
     * Sets current body position expressed in ECEF coordinates.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setEcefPosition(final Point3D position) throws LockedException {
<span class="fc bfc" id="L3103" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3104">            throw new LockedException();</span>
        }

<span class="fc" id="L3107">        biasEstimator.setEcefPosition(position);</span>
<span class="fc" id="L3108">        driftEstimator.setReferenceEcefPosition(biasEstimator.getEcefPosition());</span>
<span class="fc" id="L3109">    }</span>

    /**
     * Gets ECEF frame containing current body position and orientation expressed
     * in ECEF coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @return ECEF frame containing current body position and orientation resolved
     * around ECEF axes.
     */
    public ECEFFrame getEcefFrame() {
<span class="fc" id="L3120">        return biasEstimator.getEcefFrame();</span>
    }

    /**
     * Gets ECEF frame containing current body position and orientation expressed
     * in ECEF coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @param result instance where ECEF frame containing current body position and
     *               orientation resolved around ECEF axes will be stored.
     */
    public void getEcefFrame(final ECEFFrame result) {
<span class="fc" id="L3132">        biasEstimator.getEcefFrame(result);</span>
<span class="fc" id="L3133">    }</span>

    /**
     * Gets NED frame containing current body position and orientation expressed
     * in NED coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @return NED frame containing current body position and orientation resolved
     * around NED axes.
     */
    public NEDFrame getNedFrame() {
<span class="fc" id="L3144">        return biasEstimator.getNedFrame();</span>
    }

    /**
     * Gets NED frame containing current body position and orientation expressed
     * in NED coordinates. Frame also contains body velocity, but it is always
     * assumed to be zero during calibration.
     *
     * @param result instance where NED frame containing current body position and
     *               orientation resolved around NED axes will be stored.
     */
    public void getNedFrame(final NEDFrame result) {
<span class="fc" id="L3156">        biasEstimator.getNedFrame(result);</span>
<span class="fc" id="L3157">    }</span>

    /**
     * Gets current body position expressed in NED coordinates.
     *
     * @return current body position expressed in NED coordinates.
     */
    public NEDPosition getNedPosition() {
<span class="fc" id="L3165">        return biasEstimator.getNedPosition();</span>
    }

    /**
     * Gets current body position expressed in NED coordinates.
     *
     * @param result instance where current body position will be stored.
     */
    public void getNedPosition(final NEDPosition result) {
<span class="fc" id="L3174">        biasEstimator.getNedPosition(result);</span>
<span class="fc" id="L3175">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param position current body position to be set.
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(final NEDPosition position) throws LockedException {
<span class="fc bfc" id="L3184" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3185">            throw new LockedException();</span>
        }

<span class="fc" id="L3188">        biasEstimator.setNedPosition(position);</span>
<span class="fc" id="L3189">        driftEstimator.setReferenceNedPosition(position);</span>
<span class="fc" id="L3190">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate expressed in radians (rad).
     * @param longitude longitude NED coordinate expressed in radians (rad).
     * @param height    height NED coordinate expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(final double latitude, final double longitude, final double height)
            throws LockedException {
<span class="fc bfc" id="L3202" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3203">            throw new LockedException();</span>
        }

<span class="fc" id="L3206">        biasEstimator.setNedPosition(latitude, longitude, height);</span>
<span class="fc" id="L3207">        driftEstimator.setReferenceEcefPosition(biasEstimator.getEcefPosition());</span>
<span class="fc" id="L3208">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate.
     * @param longitude longitude NED coordinate.
     * @param height    height NED coordinate expressed in meters (m).
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(final Angle latitude, final Angle longitude, final double height)
            throws LockedException {
<span class="fc bfc" id="L3220" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3221">            throw new LockedException();</span>
        }

<span class="fc" id="L3224">        biasEstimator.setNedPosition(latitude, longitude, height);</span>
<span class="fc" id="L3225">        driftEstimator.setReferenceEcefPosition(biasEstimator.getEcefPosition());</span>
<span class="fc" id="L3226">    }</span>

    /**
     * Sets current body position expressed in NED coordinates.
     *
     * @param latitude  latitude NED coordinate.
     * @param longitude longitude NED coordinate.
     * @param height    height NED coordinate.
     * @throws LockedException if estimator is currently running.
     */
    public void setNedPosition(final Angle latitude, final Angle longitude, final Distance height)
            throws LockedException {
<span class="fc bfc" id="L3238" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3239">            throw new LockedException();</span>
        }

<span class="fc" id="L3242">        biasEstimator.setNedPosition(latitude, longitude, height);</span>
<span class="fc" id="L3243">        driftEstimator.setReferenceEcefPosition(biasEstimator.getEcefPosition());</span>
<span class="fc" id="L3244">    }</span>

    /**
     * Gets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that returned orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically, it is more convenient to use {@link #getNedC()} to get orientation
     * relative to the ground or horizon at current body position. For instance, on
     * Android devices a NED orientation with Euler angles (roll = 0, pitch = 0,
     * yaw = 0) means that the device is laying flat on a horizontal surface with the
     * screen facing down towards the ground.
     *
     * @return current body orientation resolved on ECEF axes.
     */
    public CoordinateTransformation getEcefC() {
<span class="fc" id="L3259">        return biasEstimator.getEcefC();</span>
    }

    /**
     * Gets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that returned orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically, it is more convenient to use {@link #getNedC()} to get orientation
     * relative to the ground or horizon at current body position. For instance, on
     * Android devices a NED orientation with Euler angles (roll = 0, pitch = 0,
     * yaw = 0) means that the device is laying flat on a horizontal surface with the
     * screen facing down towards the ground.
     *
     * @param result instance where current body orientation resolved on ECEF axes
     *               will be stored.
     */
    public void getEcefC(final CoordinateTransformation result) {
<span class="fc" id="L3276">        biasEstimator.getEcefC(result);</span>
<span class="fc" id="L3277">    }</span>

    /**
     * Sets current body orientation as a transformation from body to ECEF coordinates.
     * Notice that ECEF orientation refers to ECEF Earth axes, which means that
     * orientation is not relative to the ground or horizon at current body position.
     * Typically, it is more convenient to use
     * {@link #setNedC(CoordinateTransformation)} to specify orientation relative to
     * the ground or horizon at current body position.
     * For instance, on Android devices a NED orientation with Euler angles (roll = 0,
     * pitch = 0, yaw = 0) means that the device is laying flat on a horizontal surface
     * with the screen facing down towards the ground.
     *
     * @param ecefC body orientation resolved on ECEF axes to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     */
    public void setEcefC(final CoordinateTransformation ecefC) throws InvalidSourceAndDestinationFrameTypeException,
            LockedException {
<span class="fc bfc" id="L3299" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3300">            throw new LockedException();</span>
        }

<span class="fc" id="L3303">        biasEstimator.setEcefC(ecefC);</span>
<span class="fc" id="L3304">        driftEstimator.setReferenceEcefCoordinateTransformation(ecefC);</span>
<span class="fc" id="L3305">    }</span>

    /**
     * Gets current body orientation as a transformation from body to NED coordinates.
     * Notice that returned orientation refers to the current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @return current body orientation resolved on NED axes.
     */
    public CoordinateTransformation getNedC() {
<span class="fc" id="L3319">        return biasEstimator.getNedC();</span>
    }

    /**
     * Gets current body orientation as a transformation from body to NED coordinates.
     * Notice that returned orientation refers to the current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @param result instance where current body orientation resolved on NED axes
     *               will be stored.
     */
    public void getNedC(final CoordinateTransformation result) {
<span class="fc" id="L3335">        biasEstimator.getNedC(result);</span>
<span class="fc" id="L3336">    }</span>

    /**
     * Sets current body orientation as a transformation from body to NED coordinates.
     * Notice that the provided orientation refers to the current local position. This means
     * that two equal NED orientations will transform into different ECEF orientations
     * if the body is located at different positions.
     * As a reference, on Android devices a NED orientation with Euler angles
     * (roll = 0, pitch = 0, yaw = 0) means that the device is laying flat on a
     * horizontal surface with the screen facing down towards the ground.
     *
     * @param nedC orientation resolved on NED axes to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     */
    public void setNedC(final CoordinateTransformation nedC) throws InvalidSourceAndDestinationFrameTypeException,
            LockedException {
<span class="fc bfc" id="L3356" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3357">            throw new LockedException();</span>
        }

<span class="fc" id="L3360">        biasEstimator.setNedC(nedC);</span>
<span class="fc" id="L3361">        driftEstimator.setReferenceNedCoordinateTransformation(nedC);</span>
<span class="fc" id="L3362">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param nedPosition position expressed on NED coordinates.
     * @param nedC        body to NED coordinate transformation indicating
     *                    body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(NEDPosition)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(final NEDPosition nedPosition, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3380" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3381">            throw new LockedException();</span>
        }

<span class="fc" id="L3384">        biasEstimator.setNedPositionAndNedOrientation(nedPosition, nedC);</span>
<span class="fc" id="L3385">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3386">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(double, double, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final double latitude, final double longitude, final double height, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3407" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3408">            throw new LockedException();</span>
        }

<span class="fc" id="L3411">        biasEstimator.setNedPositionAndNedOrientation(latitude, longitude, height, nedC);</span>
<span class="fc" id="L3412">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3413">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final Angle latitude, final Angle longitude, final double height, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3434" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3435">            throw new LockedException();</span>
        }

<span class="fc" id="L3438">        biasEstimator.setNedPositionAndNedOrientation(latitude, longitude, height, nedC);</span>
<span class="fc" id="L3439">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3440">    }</span>

    /**
     * Sets position and orientation both expressed on NED coordinates.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param nedC      body to NED coordinate transformation indicating
     *                  body orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, Distance)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setNedPositionAndNedOrientation(
            final Angle latitude, final Angle longitude, final Distance height, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3461" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3462">            throw new LockedException();</span>
        }

<span class="fc" id="L3465">        biasEstimator.setNedPositionAndNedOrientation(latitude, longitude, height, nedC);</span>
<span class="fc" id="L3466">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3467">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param ecefC        body to ECEF coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(ECEFPosition)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final ECEFPosition ecefPosition, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3486" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3487">            throw new LockedException();</span>
        }

<span class="fc" id="L3490">        biasEstimator.setEcefPositionAndEcefOrientation(ecefPosition, ecefC);</span>
<span class="fc" id="L3491">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3492">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param x     x coordinate of ECEF position expressed in meters (m).
     * @param y     y coordinate of ECEF position expressed in meters (m).
     * @param z     z coordinate of ECEF position expressed in meters (m).
     * @param ecefC body to ECEF coordinate transformation indicating body
     *              orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(double, double, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final double x, final double y, final double z, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3513" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3514">            throw new LockedException();</span>
        }

<span class="fc" id="L3517">        biasEstimator.setEcefPositionAndEcefOrientation(x, y, z, ecefC);</span>
<span class="fc" id="L3518">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3519">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param x     x coordinate of ECEF position.
     * @param y     y coordinate of ECEF position.
     * @param z     z coordinate of ECEF position.
     * @param ecefC body to ECEF coordinate transformation indicating body
     *              orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Distance, Distance, Distance)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(
            final Distance x, final Distance y, final Distance z, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3540" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3541">            throw new LockedException();</span>
        }

<span class="fc" id="L3544">        biasEstimator.setEcefPositionAndEcefOrientation(x, y, z, ecefC);</span>
<span class="fc" id="L3545">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3546">    }</span>

    /**
     * Sets position and orientation both expressed on ECEF coordinates.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @param ecefC    body to ECEF coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Point3D)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setEcefPositionAndEcefOrientation(final Point3D position, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3564" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3565">            throw new LockedException();</span>
        }

<span class="fc" id="L3568">        biasEstimator.setEcefPositionAndEcefOrientation(position, ecefC);</span>
<span class="fc" id="L3569">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3570">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation with respect to ECEF
     * axes.
     *
     * @param position position expressed on NED coordinates.
     * @param ecefC    body to ECEF coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(NEDPosition)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final NEDPosition position, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3590" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3591">            throw new LockedException();</span>
        }

<span class="fc" id="L3594">        biasEstimator.setNedPositionAndEcefOrientation(position, ecefC);</span>
<span class="fc" id="L3595">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3596">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation with respect to ECEF
     * axes.
     *
     * @param latitude  latitude expressed in radians (rad).
     * @param longitude longitude expressed in radians (rad).
     * @param height    height expressed in meters (m).
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(double, double, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(final double latitude, final double longitude, final double height,
            final CoordinateTransformation ecefC) throws InvalidSourceAndDestinationFrameTypeException,
            LockedException {
<span class="fc bfc" id="L3618" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3619">            throw new LockedException();</span>
        }

<span class="fc" id="L3622">        biasEstimator.setNedPositionAndEcefOrientation(latitude, longitude, height, ecefC);</span>
<span class="fc" id="L3623">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3624">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation with respect to ECEF
     * axes.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height expressed in meters (m).
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, double)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final Angle latitude, final Angle longitude, final double height, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3646" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3647">            throw new LockedException();</span>
        }

<span class="fc" id="L3650">        biasEstimator.setNedPositionAndEcefOrientation(latitude, longitude, height, ecefC);</span>
<span class="fc" id="L3651">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3652">    }</span>

    /**
     * Sets position expressed on NED coordinates and orientation with respect to ECEF
     * axes.
     *
     * @param latitude  latitude.
     * @param longitude longitude.
     * @param height    height.
     * @param ecefC     body to ECEF coordinate transformation indicating body
     *                  orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if coordinate
     *                                                       transformation is not from
     *                                                       body to ECEF coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setNedPosition(Angle, Angle, Distance)
     * @see #setEcefC(CoordinateTransformation)
     */
    public void setNedPositionAndEcefOrientation(
            final Angle latitude, final Angle longitude, final Distance height, final CoordinateTransformation ecefC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3674" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3675">            throw new LockedException();</span>
        }

<span class="fc" id="L3678">        biasEstimator.setNedPositionAndEcefOrientation(latitude, longitude, height, ecefC);</span>
<span class="fc" id="L3679">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3680">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation with respect to
     * NED axes.
     * To preserve the provided orientation, the first position is set and
     * then orientation is applied.
     *
     * @param ecefPosition position expressed on ECEF coordinates.
     * @param nedC         body to NED coordinate transformation indicating body
     *                     orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(ECEFPosition)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final ECEFPosition ecefPosition, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3702" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3703">            throw new LockedException();</span>
        }

<span class="fc" id="L3706">        biasEstimator.setEcefPositionAndNedOrientation(ecefPosition, nedC);</span>
<span class="fc" id="L3707">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3708">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation with respect to
     * NED axes.
     * To preserve the provided orientation, the first position is set and
     * then orientation is applied.
     *
     * @param x    x coordinate of ECEF position expressed in meters (m).
     * @param y    y coordinate of ECEF position expressed in meters (m).
     * @param z    z coordinate of ECEF position expressed in meters (m).
     * @param nedC body to NED coordinate transformation indicating body
     *             orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(double, double, double)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final double x, final double y, final double z, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3732" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3733">            throw new LockedException();</span>
        }

<span class="fc" id="L3736">        biasEstimator.setEcefPositionAndNedOrientation(x, y, z, nedC);</span>
<span class="fc" id="L3737">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3738">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation with respect to
     * NED axes.
     * To preserve the provided orientation, the first position is set and
     * then orientation is applied.
     *
     * @param x    x coordinate of ECEF position.
     * @param y    y coordinate of ECEF position.
     * @param z    z coordinate of ECEF position.
     * @param nedC body to NED coordinate transformation indicating body
     *             orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Distance, Distance, Distance)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(
            final Distance x, final Distance y, final Distance z, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3762" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3763">            throw new LockedException();</span>
        }

<span class="fc" id="L3766">        biasEstimator.setEcefPositionAndNedOrientation(x, y, z, nedC);</span>
<span class="fc" id="L3767">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3768">    }</span>

    /**
     * Sets position expressed on ECEF coordinates and orientation with respect to
     * NED axes.
     * To preserve the provided orientation, the first position is set and
     * then orientation is applied.
     *
     * @param position position resolved around ECEF axes and expressed in meters (m).
     * @param nedC     body to NED coordinate transformation indicating body
     *                 orientation.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not from
     *                                                       body to NED coordinates.
     * @throws LockedException                               if estimator is currently
     *                                                       running.
     * @see #setEcefPosition(Point3D)
     * @see #setNedC(CoordinateTransformation)
     */
    public void setEcefPositionAndNedOrientation(final Point3D position, final CoordinateTransformation nedC)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L3789" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3790">            throw new LockedException();</span>
        }

<span class="fc" id="L3793">        biasEstimator.setEcefPositionAndNedOrientation(position, nedC);</span>
<span class="fc" id="L3794">        driftEstimator.setReferenceFrame(biasEstimator.getEcefFrame());</span>
<span class="fc" id="L3795">    }</span>

    /**
     * Gets the number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L3803">        return biasEstimator.getNumberOfProcessedSamples();</span>
    }

    /**
     * Gets the number of drift periods that have been processed.
     *
     * @return number of drift periods that have been processed.
     */
    public int getNumberOfProcessedDriftPeriods() {
<span class="fc" id="L3812">        return numberOfProcessedDriftPeriods;</span>
    }

    /**
     * Gets amount of total elapsed time since the first processed measurement expressed
     * in seconds (s).
     *
     * @return amount of total elapsed time.
     */
    public double getElapsedTimeSeconds() {
<span class="fc" id="L3822">        return biasEstimator.getElapsedTimeSeconds();</span>
    }

    /**
     * Gets the amount of total elapsed time since the first processed measurement.
     *
     * @return amount of total elapsed time.
     */
    public Time getElapsedTime() {
<span class="fc" id="L3831">        return biasEstimator.getElapsedTime();</span>
    }

    /**
     * Gets the amount of total elapsed time since the first processed measurement.
     *
     * @param result instance where the result will be stored.
     */
    public void getElapsedTime(final Time result) {
<span class="fc" id="L3840">        biasEstimator.getElapsedTime(result);</span>
<span class="fc" id="L3841">    }</span>

    /**
     * Indicates whether measured kinematics must be fixed or not.
     * When enabled, provided calibration data is used; otherwise it is
     * ignored.
     * By default, this is enabled.
     *
     * @return indicates whether measured kinematics must be fixed or not.
     */
    public boolean isFixKinematicsEnabled() {
<span class="fc" id="L3852">        return fixKinematics;</span>
    }

    /**
     * Specifies whether measured kinematics must be fixed or not.
     * When enabled, provided calibration data is used; otherwise it is
     * ignored.
     *
     * @param fixKinematics true if measured kinematics must be fixed or not.
     * @throws LockedException if estimator is currently running.
     */
    public void setFixKinematicsEnabled(final boolean fixKinematics) throws LockedException {
<span class="fc bfc" id="L3864" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3865">            throw new LockedException();</span>
        }
<span class="fc" id="L3867">        this.fixKinematics = fixKinematics;</span>
<span class="fc" id="L3868">        driftEstimator.setFixKinematicsEnabled(fixKinematics);</span>
<span class="fc" id="L3869">    }</span>

    /**
     * Gets the number of samples to be used on each drift period.
     *
     * @return number of samples to be used on each drift period.
     */
    public int getDriftPeriodSamples() {
<span class="fc" id="L3877">        return driftPeriodSamples;</span>
    }

    /**
     * Sets the number of samples to be used on each drift period.
     *
     * @param driftPeriodSamples number of samples to be used on each drift period.
     * @throws LockedException          if estimator is currently running.
     * @throws IllegalArgumentException if provided value is negative or zero.
     */
    public void setDriftPeriodSamples(int driftPeriodSamples) throws LockedException {
<span class="pc bpc" id="L3888" title="1 of 2 branches missed.">        if (running) {</span>
<span class="fc" id="L3889">            throw new LockedException();</span>
        }
<span class="nc bnc" id="L3891" title="All 2 branches missed.">        if (driftPeriodSamples &lt;= 0) {</span>
<span class="nc" id="L3892">            throw new IllegalArgumentException();</span>
        }

<span class="nc" id="L3895">        this.driftPeriodSamples = driftPeriodSamples;</span>
<span class="nc" id="L3896">    }</span>

    /**
     * Gets the duration of each drift period expressed in seconds (s).
     *
     * @return duration of each drift period.
     */
    public double getDriftPeriodSeconds() {
<span class="fc" id="L3904">        return driftPeriodSamples * getTimeInterval();</span>
    }

    /**
     * Gets the duration of each drift period.
     *
     * @return duration of each drift period.
     */
    public Time getDriftPeriod() {
<span class="fc" id="L3913">        return new Time(getDriftPeriodSeconds(), TimeUnit.SECOND);</span>
    }

    /**
     * Gets the duration of each drift period.
     *
     * @param result instance where the result will be stored.
     */
    public void getDriftPeriod(final Time result) {
<span class="fc" id="L3922">        result.setValue(getDriftPeriodSeconds());</span>
<span class="fc" id="L3923">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L3924">    }</span>

    /**
     * Indicates whether this estimator is running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L3932">        return running;</span>
    }

    /**
     * Indicates if estimator is ready to start processing additional kinematics
     * measurements.
     *
     * @return true if ready, false otherwise.
     */
    public boolean isReady() {
<span class="fc" id="L3942">        return driftEstimator.isReady();</span>
    }

    /**
     * Adds a sample of measured body kinematics (accelerometer and gyroscope readings)
     * obtained from an IMU, fixes their values and uses fixed values to estimate
     * any additional existing bias or position and velocity variation while the
     * IMU body remains static.
     *
     * @param kinematics measured body kinematics.
     * @throws LockedException               if estimator is currently running.
     * @throws RandomWalkEstimationException if estimation fails for some reason.
     * @throws NotReadyException             if estimator is not ready.
     */
    public void addBodyKinematics(final BodyKinematics kinematics) throws LockedException,
            RandomWalkEstimationException, NotReadyException {

<span class="fc bfc" id="L3959" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L3960">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L3963" title="1 of 2 branches missed.">        if (!driftEstimator.isReady()) {</span>
<span class="nc" id="L3964">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L3968">            running = true;</span>

<span class="fc" id="L3970">            final var numberOfSamples = getNumberOfProcessedSamples();</span>

<span class="fc bfc" id="L3972" title="All 4 branches covered.">            if (numberOfSamples == 0 &amp;&amp; listener != null) {</span>
<span class="fc" id="L3973">                listener.onStart(this);</span>
            }

<span class="fc bfc" id="L3976" title="All 2 branches covered.">            if (fixKinematics) {</span>
<span class="fc" id="L3977">                fixer.fix(kinematics, fixedKinematics);</span>
            } else {
<span class="fc" id="L3979">                fixedKinematics.copyFrom(kinematics);</span>
            }

<span class="fc" id="L3982">            biasEstimator.addBodyKinematics(fixedKinematics);</span>

<span class="fc" id="L3984">            final var timeInterval = getTimeInterval();</span>

            // update random walk values)

            // Get accumulated mean of bias values for all processed samples.
            // If calibration and sensor were perfect, this should be zero
<span class="fc" id="L3990">            final var elapsedTime = getElapsedTimeSeconds();</span>
<span class="fc" id="L3991">            biasEstimator.getBiasF(accelerationTriad);</span>
<span class="fc" id="L3992">            biasEstimator.getBiasAngularRate(angularSpeedTriad);</span>

<span class="fc" id="L3994">            final var accelerationBiasNorm = accelerationTriad.getNorm();</span>
<span class="fc" id="L3995">            final var angularSpeedBiasNorm = angularSpeedTriad.getNorm();</span>

            // estimate rates of variation PSD's of bias values for all processed
            // samples
<span class="fc" id="L3999">            accelerometerBiasPSD = Math.pow(accelerationBiasNorm / elapsedTime, 2.0) * timeInterval;</span>
<span class="fc" id="L4000">            gyroBiasPSD = Math.pow(angularSpeedBiasNorm / elapsedTime, 2.0) * timeInterval;</span>

            // internally drift estimator will fix kinematics if needed
<span class="fc" id="L4003">            driftEstimator.addBodyKinematics(kinematics);</span>

<span class="fc bfc" id="L4005" title="All 2 branches covered.">            if (numberOfSamples % driftPeriodSamples == 0) {</span>
                // for each drift period, update mean and variance values
                // of drift and reset drift estimator
<span class="fc" id="L4008">                final var n = numberOfProcessedDriftPeriods + 1.0;</span>
<span class="fc" id="L4009">                final var tmp = numberOfProcessedDriftPeriods / n;</span>

<span class="fc" id="L4011">                final var positionDrift = driftEstimator.getCurrentPositionDriftNormMeters();</span>
<span class="fc" id="L4012">                final var velocityDrift = driftEstimator.getCurrentVelocityDriftNormMetersPerSecond();</span>
<span class="fc" id="L4013">                final var attitudeDrift = driftEstimator.getCurrentOrientationDriftRadians();</span>

<span class="fc" id="L4015">                avgPositionDrift = avgPositionDrift * tmp + positionDrift / n;</span>
<span class="fc" id="L4016">                avgVelocityDrift = avgVelocityDrift * tmp + velocityDrift / n;</span>
<span class="fc" id="L4017">                avgAttitudeDrift = avgAttitudeDrift * tmp + attitudeDrift / n;</span>

<span class="fc" id="L4019">                final var diffPositionDrift = positionDrift - avgPositionDrift;</span>
<span class="fc" id="L4020">                final var diffVelocityDrift = velocityDrift - avgVelocityDrift;</span>
<span class="fc" id="L4021">                final var diffAttitudeDrift = attitudeDrift - avgAttitudeDrift;</span>

<span class="fc" id="L4023">                final var diffPositionDrift2 = diffPositionDrift * diffPositionDrift;</span>
<span class="fc" id="L4024">                final var diffVelocityDrift2 = diffVelocityDrift * diffVelocityDrift;</span>
<span class="fc" id="L4025">                final var diffAttitudeDrift2 = diffAttitudeDrift * diffAttitudeDrift;</span>

<span class="fc" id="L4027">                varPositionDrift = varPositionDrift * tmp + diffPositionDrift2 / n;</span>
<span class="fc" id="L4028">                varVelocityDrift = varVelocityDrift * tmp + diffVelocityDrift2 / n;</span>
<span class="fc" id="L4029">                varAttitudeDrift = varAttitudeDrift * tmp + diffAttitudeDrift2 / n;</span>

<span class="fc" id="L4031">                driftEstimator.reset();</span>
<span class="fc" id="L4032">                numberOfProcessedDriftPeriods++;</span>
            }

<span class="fc bfc" id="L4035" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L4036">                listener.onBodyKinematicsAdded(this, kinematics, fixedKinematics);</span>
            }

<span class="nc" id="L4039">        } catch (AlgebraException | DriftEstimationException e) {</span>
<span class="nc" id="L4040">            throw new RandomWalkEstimationException(e);</span>
        } finally {
<span class="fc" id="L4042">            running = false;</span>
        }
<span class="fc" id="L4044">    }</span>

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L4053" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L4054">            throw new LockedException();</span>
        }

<span class="fc" id="L4057">        running = true;</span>
<span class="fc bfc" id="L4058" title="All 2 branches covered.">        if (biasEstimator.reset()) {</span>
<span class="fc" id="L4059">            accelerometerBiasPSD = 0.0;</span>
<span class="fc" id="L4060">            gyroBiasPSD = 0.0;</span>
<span class="fc" id="L4061">            numberOfProcessedDriftPeriods = 0;</span>
<span class="fc" id="L4062">            avgPositionDrift = 0.0;</span>
<span class="fc" id="L4063">            avgVelocityDrift = 0.0;</span>
<span class="fc" id="L4064">            avgAttitudeDrift = 0.0;</span>
<span class="fc" id="L4065">            varPositionDrift = 0.0;</span>
<span class="fc" id="L4066">            varVelocityDrift = 0.0;</span>
<span class="fc" id="L4067">            varAttitudeDrift = 0.0;</span>

<span class="pc bpc" id="L4069" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L4070">                listener.onReset(this);</span>
            }

<span class="fc" id="L4073">            running = false;</span>
<span class="fc" id="L4074">            return true;</span>
        } else {
<span class="fc" id="L4076">            running = false;</span>
<span class="fc" id="L4077">            return false;</span>
        }
    }

    /**
     * Gets estimated accelerometer bias random walk PSD (Power Spectral Density)
     * expressed in (m^2 * s^-5).
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @return accelerometer bias random walk PSD.
     */
    @Override
    public double getAccelerometerBiasPSD() {
<span class="fc" id="L4090">        return accelerometerBiasPSD;</span>
    }

    /**
     * Gets estimated gyro bias random walk PSD (Power Spectral Density)
     * expressed in (rad^2 * s^-3).
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @return gyroscope bias random walk PSD.
     */
    @Override
    public double getGyroBiasPSD() {
<span class="fc" id="L4102">        return gyroBiasPSD;</span>
    }

    /**
     * Gets estimated position noise variance expressed in square meters (m^2).
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @return position variance.
     */
    public double getPositionNoiseVariance() {
<span class="fc" id="L4112">        return varPositionDrift;</span>
    }

    /**
     * Gets estimated velocity noise variance expressed in (m^2/s^2).
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @return velocity variance.
     */
    public double getVelocityNoiseVariance() {
<span class="fc" id="L4122">        return varVelocityDrift;</span>
    }

    /**
     * Gets estimated attitude noise variance expressed in squared radians (rad^2).
     *
     * @return attitude variance.
     */
    public double getAttitudeNoiseVariance() {
<span class="fc" id="L4131">        return varAttitudeDrift;</span>
    }

    /**
     * Gets standard deviation of position noise expressed in meters (m).
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @return standard deviation of position noise.
     */
    @Override
    public double getPositionNoiseStandardDeviation() {
<span class="fc" id="L4142">        return Math.sqrt(varPositionDrift);</span>
    }

    /**
     * Gets standard deviation of position noise.
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @return standard deviation of position noise.
     */
    public Distance getPositionNoiseStandardDeviationAsDistance() {
<span class="fc" id="L4152">        return new Distance(getPositionNoiseStandardDeviation(), DistanceUnit.METER);</span>
    }

    /**
     * Gets standard deviation of position noise.
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @param result instance where the result will be stored.
     */
    public void getPositionNoiseStandardDeviationAsDistance(final Distance result) {
<span class="fc" id="L4162">        result.setValue(getPositionNoiseStandardDeviation());</span>
<span class="fc" id="L4163">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L4164">    }</span>

    /**
     * Gets standard deviation of velocity noise expressed in meters per second
     * (m/s).
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @return standard deviation of velocity noise.
     */
    @Override
    public double getVelocityNoiseStandardDeviation() {
<span class="fc" id="L4175">        return Math.sqrt(varVelocityDrift);</span>
    }

    /**
     * Gets standard deviation of velocity noise.
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @return standard deviation of velocity noise.
     */
    public Speed getVelocityNoiseStandardDeviationAsSpeed() {
<span class="fc" id="L4185">        return new Speed(getVelocityNoiseStandardDeviation(), SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Gets standard deviation of velocity noise.
     * This can be used by {@link INSLooselyCoupledKalmanConfig}.
     *
     * @param result instance where the result will be stored.
     */
    public void getVelocityNoiseStandardDeviationAsSpeed(final Speed result) {
<span class="fc" id="L4195">        result.setValue(getVelocityNoiseStandardDeviation());</span>
<span class="fc" id="L4196">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L4197">    }</span>

    /**
     * Gets standard deviation of attitude noise expressed in radians (rad).
     *
     * @return standard deviation of attitude noise.
     */
    public double getAttitudeNoiseStandardDeviation() {
<span class="fc" id="L4205">        return Math.sqrt(varAttitudeDrift);</span>
    }

    /**
     * Gets standard deviation of attitude noise.
     *
     * @return standard deviation of attitude noise.
     */
    public Angle getAttitudeNoiseStandardDeviationAsAngle() {
<span class="fc" id="L4214">        return new Angle(getAttitudeNoiseStandardDeviation(), AngleUnit.RADIANS);</span>
    }

    /**
     * Gets standard deviation of attitude noise.
     *
     * @param result instance where the result will be stored.
     */
    public void getAttitudeNoiseStandardDeviationAsAngle(final Angle result) {
<span class="fc" id="L4223">        result.setValue(getAttitudeNoiseStandardDeviation());</span>
<span class="fc" id="L4224">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L4225">    }</span>

    /**
     * Gets position uncertainty expressed in meters (m).
     *
     * @return position uncertainty.
     */
    @Override
    public double getPositionUncertainty() {
<span class="fc" id="L4234">        return avgPositionDrift;</span>
    }

    /**
     * Gets position uncertainty.
     *
     * @return position uncertainty.
     */
    public Distance getPositionUncertaintyAsDistance() {
<span class="fc" id="L4243">        return new Distance(getPositionUncertainty(), DistanceUnit.METER);</span>
    }

    /**
     * Gets position uncertainty.
     *
     * @param result instance where the result will be stored.
     */
    public void getPositionUncertaintyAsDistance(final Distance result) {
<span class="fc" id="L4252">        result.setValue(getPositionUncertainty());</span>
<span class="fc" id="L4253">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L4254">    }</span>

    /**
     * Gets velocity uncertainty expressed in meters per second (m/s).
     *
     * @return velocity uncertainty.
     */
    @Override
    public double getVelocityUncertainty() {
<span class="fc" id="L4263">        return avgVelocityDrift;</span>
    }

    /**
     * Gets velocity uncertainty.
     *
     * @return velocity uncertainty.
     */
    public Speed getVelocityUncertaintyAsSpeed() {
<span class="fc" id="L4272">        return new Speed(getVelocityUncertainty(), SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Gets velocity uncertainty.
     *
     * @param result instance where the result will be stored.
     */
    public void getVelocityUncertaintyAsSpeed(final Speed result) {
<span class="fc" id="L4281">        result.setValue(getVelocityUncertainty());</span>
<span class="fc" id="L4282">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L4283">    }</span>

    /**
     * Gets attitude uncertainty expressed in radians (rad).
     *
     * @return attitude uncertainty.
     */
    @Override
    public double getAttitudeUncertainty() {
<span class="fc" id="L4292">        return avgAttitudeDrift;</span>
    }

    /**
     * Gets attitude uncertainty.
     *
     * @return attitude uncertainty.
     */
    public Angle getAttitudeUncertaintyAsAngle() {
<span class="fc" id="L4301">        return new Angle(getAttitudeUncertainty(), AngleUnit.RADIANS);</span>
    }

    /**
     * Gets attitude uncertainty.
     *
     * @param result instance where the result will be stored.
     */
    public void getAttitudeUncertaintyAsAngle(final Angle result) {
<span class="fc" id="L4310">        result.setValue(getAttitudeUncertainty());</span>
<span class="fc" id="L4311">        result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L4312">    }</span>

    /**
     * Gets last added kinematics after being fixed using provided
     * calibration data.
     * If kinematics fix is disabled, this will be equal to the last
     * provided measured kinematics.
     *
     * @return last fixed body kinematics.
     */
    public BodyKinematics getFixedKinematics() {
<span class="fc" id="L4323">        return fixedKinematics;</span>
    }

    /**
     * Gets last added kinematics after being fixed using provided
     * calibration data.
     * If kinematics fix is disabled, this will be equal to the last
     * provided measured kinematics.
     *
     * @param result last fixed body kinematics.
     */
    public void getFixedKinematics(final BodyKinematics result) {
<span class="fc" id="L4335">        result.copyFrom(fixedKinematics);</span>
<span class="fc" id="L4336">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>