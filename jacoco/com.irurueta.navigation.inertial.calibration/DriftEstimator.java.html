<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DriftEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial-extra</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">DriftEstimator.java</span></div><h1>DriftEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2021 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.InvalidRotationMatrixException;
import com.irurueta.geometry.Quaternion;
import com.irurueta.geometry.Rotation3D;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.ECEFPosition;
import com.irurueta.navigation.frames.ECEFVelocity;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.frames.NEDFrame;
import com.irurueta.navigation.frames.NEDPosition;
import com.irurueta.navigation.frames.NEDVelocity;
import com.irurueta.navigation.frames.converters.ECEFtoNEDFrameConverter;
import com.irurueta.navigation.frames.converters.NEDtoECEFFrameConverter;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.navigators.ECEFInertialNavigator;
import com.irurueta.navigation.inertial.navigators.InertialNavigatorException;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.Angle;
import com.irurueta.units.AngleUnit;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedUnit;
import com.irurueta.units.Distance;
import com.irurueta.units.DistanceUnit;
import com.irurueta.units.Speed;
import com.irurueta.units.SpeedUnit;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

/**
 * Estimates accumulated drift in body orientation, position and velocity per
 * unit of time.
 * This estimator must be executed while the body where the IMU is placed remains
 * static.
 */
public class DriftEstimator {

    /**
     * Default time interval between kinematics samples expressed in seconds (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Indicates whether this estimator is running.
     */
    protected boolean running;

    /**
     * Number of processed body kinematics samples.
     */
    protected int numberOfProcessedSamples;

    /**
     * Time interval expressed in seconds (s) between body kinematics samples.
     */
<span class="fc" id="L78">    protected double timeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Fixes body kinematics measurements using accelerometer and gyroscope
     * calibration data to fix measurements.
     */
<span class="fc" id="L84">    protected final BodyKinematicsFixer fixer = new BodyKinematicsFixer();</span>

    /**
     * Instance containing the last fixed body kinematics to be reused.
     */
<span class="fc" id="L89">    protected final BodyKinematics fixedKinematics = new BodyKinematics();</span>

    /**
     * Indicates whether measured kinematics must be fixed or not.
     * When enabled, provided calibration data is used; otherwise it is
     * ignored.
     * By default, this is enabled.
     */
<span class="fc" id="L97">    protected boolean fixKinematics = true;</span>

    /**
     * Listener to handle events raised by this estimator.
     */
    protected DriftEstimatorListener listener;

    /**
     * Initial frame containing body position, velocity and orientation expressed
     * in ECEF coordinates before starting drift estimation.
     */
    protected ECEFFrame referenceFrame;

    /**
     * Contains the current frame after one navigation step.
     * This is reused for efficiency.
     */
<span class="fc" id="L114">    protected final ECEFFrame frame = new ECEFFrame();</span>

    /**
     * Contains orientation of a reference frame.
     * This is reused for efficiency.
     */
<span class="fc" id="L120">    protected final Quaternion refQ = new Quaternion();</span>

    /**
     * Contains orientation inverse of the reference frame.
     * This is reused for efficiency.
     */
<span class="fc" id="L126">    protected final Quaternion invRefQ = new Quaternion();</span>

    /**
     * Contains current frame orientation drift.
     * This is reused for efficiency.
     */
<span class="fc" id="L132">    protected final Quaternion q = new Quaternion();</span>

    /**
     * Contains current position drift.
     */
<span class="fc" id="L137">    protected final ECEFPosition currentPositionDrift = new ECEFPosition();</span>

    /**
     * Contains current velocity drift.
     */
<span class="fc" id="L142">    protected final ECEFVelocity currentVelocityDrift = new ECEFVelocity();</span>

    /**
     * Contains current orientation expressed as a 3D rotation matrix.
     */
    protected Matrix currentC;

    /**
     * Current position drift expressed in meters (m).
     */
    protected double currentPositionDriftMeters;

    /**
     * Current velocity drift expressed in meters per second (m/s).
     */
    protected double currentVelocityDriftMetersPerSecond;

    /**
     * Current orientation drift expressed in radians (rad).
     */
    protected double currentOrientationDriftRadians;

    /**
     * Constructor.
     */
<span class="fc" id="L167">    public DriftEstimator() {</span>
<span class="fc" id="L168">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events.
     */
<span class="fc" id="L175">    public DriftEstimator(final DriftEstimatorListener listener) {</span>
<span class="fc" id="L176">        this.listener = listener;</span>
<span class="fc" id="L177">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     */
<span class="fc" id="L185">    public DriftEstimator(final ECEFFrame referenceFrame) {</span>
<span class="fc" id="L186">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L187">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param listener       listener to handle events.
     */
    public DriftEstimator(final ECEFFrame referenceFrame,
<span class="fc" id="L197">                          final DriftEstimatorListener listener) {</span>
<span class="fc" id="L198">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L199">        this.listener = listener;</span>
<span class="fc" id="L200">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     */
<span class="fc" id="L208">    public DriftEstimator(final NEDFrame referenceFrame) {</span>
        try {
<span class="fc" id="L210">            setReferenceNedFrame(referenceFrame);</span>
<span class="nc" id="L211">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L213">        }</span>
<span class="fc" id="L214">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     * @param listener       listener to handle events.
     */
    public DriftEstimator(final NEDFrame referenceFrame,
                          final DriftEstimatorListener listener) {
<span class="fc" id="L225">        this(referenceFrame);</span>
<span class="fc" id="L226">        this.listener = listener;</span>
<span class="fc" id="L227">    }</span>

    /**
     * Constructor.
     *
     * @param ba acceleration bias to be set.
     * @param ma acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg angular speed bias to be set.
     * @param mg angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(final AccelerationTriad ba,
                          final Matrix ma,
                          final AngularSpeedTriad bg,
<span class="fc" id="L243">                          final Matrix mg) throws AlgebraException {</span>
        try {
<span class="fc" id="L245">            setAccelerationBias(ba);</span>
<span class="fc" id="L246">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L247">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L248">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="nc" id="L249">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L251">        }</span>
<span class="fc" id="L252">    }</span>

    /**
     * Constructor.
     *
     * @param ba       acceleration bias to be set.
     * @param ma       acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg       angular speed bias to be set.
     * @param mg       angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L272">        this(ba, ma, bg, mg);</span>
<span class="fc" id="L273">        this.listener = listener;</span>
<span class="fc" id="L274">    }</span>

    /**
     * Constructor.
     *
     * @param ba acceleration bias to be set.
     * @param ma acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg angular speed bias to be set.
     * @param mg angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg) throws AlgebraException {
<span class="fc" id="L294">        this(ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L296">            setAngularSpeedGDependantCrossBias(gg);</span>
<span class="nc" id="L297">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L299">        }</span>
<span class="fc" id="L300">    }</span>

    /**
     * Constructor.
     *
     * @param ba       acceleration bias to be set.
     * @param ma       acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg       angular speed bias to be set.
     * @param mg       angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg       angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L322">        this(ba, ma, bg, mg, gg);</span>
<span class="fc" id="L323">        this.listener = listener;</span>
<span class="fc" id="L324">    }</span>

    /**
     * Constructor.
     *
     * @param ba acceleration bias to be set expressed in meters per squared second
     *           (m/s`2). Must be 3x1.
     * @param ma acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg angular speed bias to be set expressed in radians per second
     *           (rad/s). Must be 3x1.
     * @param mg angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
<span class="fc" id="L343">            final Matrix mg) throws AlgebraException {</span>
        try {
<span class="fc" id="L345">            setAccelerationBias(ba);</span>
<span class="fc" id="L346">            setAccelerationCrossCouplingErrors(ma);</span>
<span class="fc" id="L347">            setAngularSpeedBias(bg);</span>
<span class="fc" id="L348">            setAngularSpeedCrossCouplingErrors(mg);</span>
<span class="nc" id="L349">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L351">        }</span>
<span class="fc" id="L352">    }</span>

    /**
     * Constructor.
     *
     * @param ba       acceleration bias to be set expressed in meters per squared second
     *                 (m/s`2). Must be 3x1.
     * @param ma       acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg       angular speed bias to be set expressed in radians per second
     *                 (rad/s). Must be 3x1.
     * @param mg       angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L374">        this(ba, ma, bg, mg);</span>
<span class="fc" id="L375">        this.listener = listener;</span>
<span class="fc" id="L376">    }</span>

    /**
     * Constructor.
     *
     * @param ba acceleration bias to be set expressed in meters per squared second
     *           (m/s`2). Must be 3x1.
     * @param ma acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg angular speed bias to be set expressed in radians per second
     *           (rad/s). Must be 3x1.
     * @param mg angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg) throws AlgebraException {
<span class="fc" id="L398">        this(ba, ma, bg, mg);</span>
        try {
<span class="fc" id="L400">            setAngularSpeedGDependantCrossBias(gg);</span>
<span class="nc" id="L401">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L403">        }</span>
<span class="fc" id="L404">    }</span>

    /**
     * Constructor.
     *
     * @param ba       acceleration bias to be set expressed in meters per squared second
     *                 (m/s`2). Must be 3x1.
     * @param ma       acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg       angular speed bias to be set expressed in radians per second
     *                 (rad/s). Must be 3x1.
     * @param mg       angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg       angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L428">        this(ba, ma, bg, mg, gg);</span>
<span class="fc" id="L429">        this.listener = listener;</span>
<span class="fc" id="L430">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(final ECEFFrame referenceFrame,
                          final AccelerationTriad ba,
                          final Matrix ma,
                          final AngularSpeedTriad bg,
                          final Matrix mg) throws AlgebraException {
<span class="fc" id="L450">        this(ba, ma, bg, mg);</span>
<span class="fc" id="L451">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L452">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener       listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final ECEFFrame referenceFrame,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L475">        this(ba, ma, bg, mg, listener);</span>
<span class="fc" id="L476">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L477">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg             angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final ECEFFrame referenceFrame,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg) throws AlgebraException {
<span class="fc" id="L500">        this(ba, ma, bg, mg, gg);</span>
<span class="fc" id="L501">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L502">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg             angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener       listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final ECEFFrame referenceFrame,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L527">        this(ba, ma, bg, mg, gg, listener);</span>
<span class="fc" id="L528">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L529">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set expressed in meters per squared second
     *                       (m/s`2). Must be 3x1.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set expressed in radians per second
     *                       (rad/s). Must be 3x1.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final ECEFFrame referenceFrame,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg) throws AlgebraException {
<span class="fc" id="L552">        this(ba, ma, bg, mg);</span>
<span class="fc" id="L553">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L554">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set expressed in meters per squared second
     *                       (m/s`2). Must be 3x1.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set expressed in radians per second
     *                       (rad/s). Must be 3x1.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener       listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final ECEFFrame referenceFrame,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L579">        this(ba, ma, bg, mg, listener);</span>
<span class="fc" id="L580">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L581">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set expressed in meters per squared second
     *                       (m/s`2). Must be 3x1.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set expressed in radians per second
     *                       (rad/s). Must be 3x1.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg             angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final ECEFFrame referenceFrame,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg) throws AlgebraException {
<span class="fc" id="L606">        this(ba, ma, bg, mg, gg);</span>
<span class="fc" id="L607">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L608">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set expressed in meters per squared second
     *                       (m/s`2). Must be 3x1.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set expressed in radians per second
     *                       (rad/s). Must be 3x1.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg             angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener       listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final ECEFFrame referenceFrame,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L635">        this(ba, ma, bg, mg, gg, listener);</span>
<span class="fc" id="L636">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L637">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     * @param ba             acceleration bias to be set.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(final NEDFrame referenceFrame,
                          final AccelerationTriad ba,
                          final Matrix ma,
                          final AngularSpeedTriad bg,
                          final Matrix mg) throws AlgebraException {
<span class="fc" id="L657">        this(NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceFrame), ba, ma, bg, mg);</span>
<span class="fc" id="L658">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     * @param ba             acceleration bias to be set.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener       listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final NEDFrame referenceFrame,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L681">        this(NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceFrame), ba, ma, bg, mg, listener);</span>
<span class="fc" id="L682">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     * @param ba             acceleration bias to be set.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg             angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final NEDFrame referenceFrame,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg) throws AlgebraException {
<span class="fc" id="L705">        this(NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceFrame), ba, ma, bg, mg, gg);</span>
<span class="fc" id="L706">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     * @param ba             acceleration bias to be set.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg             angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener       listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final NEDFrame referenceFrame,
            final AccelerationTriad ba,
            final Matrix ma,
            final AngularSpeedTriad bg,
            final Matrix mg,
            final Matrix gg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L731">        this(NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceFrame), ba, ma, bg, mg, gg, listener);</span>
<span class="fc" id="L732">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     * @param ba             acceleration bias to be set expressed in meters per squared second
     *                       (m/s`2). Must be 3x1.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set expressed in radians per second
     *                       (rad/s). Must be 3x1.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final NEDFrame referenceFrame,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg) throws AlgebraException {
<span class="fc" id="L755">        this(NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceFrame), ba, ma, bg, mg);</span>
<span class="fc" id="L756">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     * @param ba             acceleration bias to be set expressed in meters per squared second
     *                       (m/s`2). Must be 3x1.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set expressed in radians per second
     *                       (rad/s). Must be 3x1.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param listener       listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final NEDFrame referenceFrame,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L781">        this(NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceFrame), ba, ma, bg, mg, listener);</span>
<span class="fc" id="L782">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in NED coordinates.
     * @param ba             acceleration bias to be set expressed in meters per squared second
     *                       (m/s`2). Must be 3x1.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set expressed in radians per second
     *                       (rad/s). Must be 3x1.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg             angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final NEDFrame referenceFrame,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg) throws AlgebraException {
<span class="fc" id="L807">        this(NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceFrame), ba, ma, bg, mg, gg);</span>
<span class="fc" id="L808">    }</span>

    /**
     * Constructor.
     *
     * @param referenceFrame initial frame containing body position, velocity and
     *                       orientation expressed in ECEF coordinates.
     * @param ba             acceleration bias to be set expressed in meters per squared second
     *                       (m/s`2). Must be 3x1.
     * @param ma             acceleration cross-coupling errors matrix. Must be 3x3.
     * @param bg             angular speed bias to be set expressed in radians per second
     *                       (rad/s). Must be 3x1.
     * @param mg             angular speed cross-coupling errors matrix. Must be 3x3.
     * @param gg             angular speed g-dependent cross-biases matrix. Must be 3x3.
     * @param listener       listener to handle events.
     * @throws AlgebraException         if provided cross-coupling matrices cannot
     *                                  be inverted.
     * @throws IllegalArgumentException if any provided matrices are not 3x3.
     */
    public DriftEstimator(
            final NEDFrame referenceFrame,
            final Matrix ba,
            final Matrix ma,
            final Matrix bg,
            final Matrix mg,
            final Matrix gg,
            final DriftEstimatorListener listener) throws AlgebraException {
<span class="fc" id="L835">        this(NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceFrame), ba, ma, bg, mg, gg, listener);</span>
<span class="fc" id="L836">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public DriftEstimatorListener getListener() {
<span class="fc" id="L844">        return listener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if estimator is running.
     */
    public void setListener(final DriftEstimatorListener listener) throws LockedException {
<span class="fc bfc" id="L854" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L855">            throw new LockedException();</span>
        }

<span class="fc" id="L858">        this.listener = listener;</span>
<span class="fc" id="L859">    }</span>

    /**
     * Gets initial frame containing body position, velocity and orientation
     * expressed in ECEF coordinates before starting drift estimation.
     *
     * @return initial body frame or null.
     */
    public ECEFFrame getReferenceFrame() {
<span class="fc" id="L868">        return referenceFrame;</span>
    }

    /**
     * Sets initial frame containing body position, velocity and orientation
     * expressed in ECEF coordinates before starting drift estimation.
     *
     * @param referenceFrame initial frame or null.
     * @throws LockedException if estimator is already running.
     */
    public void setReferenceFrame(final ECEFFrame referenceFrame) throws LockedException {
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L880">            throw new LockedException();</span>
        }
<span class="fc" id="L882">        this.referenceFrame = referenceFrame;</span>
<span class="fc" id="L883">    }</span>

    /**
     * Gets initial frame containing body position, velocity and orientation
     * expressed in NED coordinates before starting drift estimation.
     *
     * @return initial body frame or null.
     */
    public NEDFrame getReferenceNedFrame() {
<span class="fc bfc" id="L892" title="All 2 branches covered.">        return referenceFrame != null</span>
<span class="fc" id="L893">                ? ECEFtoNEDFrameConverter.convertECEFtoNEDAndReturnNew(referenceFrame)</span>
<span class="fc" id="L894">                : null;</span>
    }

    /**
     * Gets initial frame containing body position, velocity and orientation
     * expressed in NED coordinates before starting drift estimation.
     *
     * @param result instance where the result will be stored.
     * @return true if the initial frame was available and the result was updated, false
     * otherwise.
     * @throws NullPointerException if provided result instance is null.
     */
    public boolean getReferenceNedFrame(final NEDFrame result) {
<span class="fc bfc" id="L907" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L908">            ECEFtoNEDFrameConverter.convertECEFtoNED(referenceFrame, result);</span>
<span class="fc" id="L909">            return true;</span>
        } else {
<span class="fc" id="L911">            return false;</span>
        }
    }

    /**
     * Sets an initial frame containing body position, velocity and orientation
     * expressed in NED coordinates before starting drift estimation.
     *
     * @param referenceNedFrame initial body frame or null.
     * @throws LockedException if estimator is already running.
     */
    public void setReferenceNedFrame(final NEDFrame referenceNedFrame) throws LockedException {
<span class="fc bfc" id="L923" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L924">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L927" title="All 2 branches covered.">        if (referenceNedFrame != null) {</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">            if (referenceFrame != null) {</span>
<span class="fc" id="L929">                NEDtoECEFFrameConverter.convertNEDtoECEF(referenceNedFrame, referenceFrame);</span>
            } else {
<span class="fc" id="L931">                referenceFrame = NEDtoECEFFrameConverter.convertNEDtoECEFAndReturnNew(referenceNedFrame);</span>
            }
        } else {
<span class="fc" id="L934">            referenceFrame = null;</span>
        }
<span class="fc" id="L936">    }</span>

    /**
     * Gets initial body position, expressed in ECEF coordinates, before starting
     * drift estimation.
     *
     * @return initial body position or null.
     */
    public ECEFPosition getReferenceEcefPosition() {
<span class="fc bfc" id="L945" title="All 2 branches covered.">        return referenceFrame != null ? referenceFrame.getECEFPosition() : null;</span>
    }

    /**
     * Gets initial body position, expressed in ECEF coordinates, before starting
     * drift estimation.
     *
     * @param result instance where the result will be stored.
     * @return true if the initial body position was available and the result was updated,
     * false otherwise.
     * @throws NullPointerException if provided result instance is null.
     */
    public boolean getReferenceEcefPosition(final ECEFPosition result) {
<span class="fc bfc" id="L958" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L959">            referenceFrame.getECEFPosition(result);</span>
<span class="fc" id="L960">            return true;</span>
        } else {
<span class="fc" id="L962">            return false;</span>
        }
    }

    /**
     * Sets initial body position, expressed in ECEF coordinates, before starting
     * drift estimation.
     *
     * @param referenceEcefPosition initial body position.
     * @throws LockedException      if estimator is already running.
     * @throws NullPointerException if provided position is null.
     */
    public void setReferenceEcefPosition(final ECEFPosition referenceEcefPosition) throws LockedException {
<span class="fc bfc" id="L975" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L976">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L979" title="1 of 2 branches missed.">        if (referenceFrame != null) {</span>
<span class="nc" id="L980">            referenceFrame.setPosition(referenceEcefPosition);</span>
        } else {
<span class="fc" id="L982">            referenceFrame = new ECEFFrame(referenceEcefPosition);</span>
        }
<span class="fc" id="L984">    }</span>

    /**
     * Gets initial body velocity, expressed in ECEF coordinates, before starting
     * drift estimation.
     *
     * @return initial body velocity or null.
     */
    public ECEFVelocity getReferenceEcefVelocity() {
<span class="fc bfc" id="L993" title="All 2 branches covered.">        return referenceFrame != null ? referenceFrame.getECEFVelocity() : null;</span>
    }

    /**
     * Gets initial body velocity, expressed in ECEF coordinates, before starting
     * drift estimation.
     *
     * @param result instance where the result will be stored.
     * @return true if initial body velocity was available and the result was updated,
     * false otherwise.
     * @throws NullPointerException if provided result instance is null.
     */
    public boolean getReferenceEcefVelocity(final ECEFVelocity result) {
<span class="fc bfc" id="L1006" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L1007">            referenceFrame.getECEFVelocity(result);</span>
<span class="fc" id="L1008">            return true;</span>
        } else {
<span class="fc" id="L1010">            return false;</span>
        }
    }

    /**
     * Sets initial body velocity, expressed in ECEF coordinates, before starting
     * drift estimation.
     *
     * @param referenceEcefVelocity initial body velocity.
     * @throws LockedException      if estimator is already running.
     * @throws NullPointerException if velocity is null.
     */
    public void setReferenceEcefVelocity(final ECEFVelocity referenceEcefVelocity) throws LockedException {
<span class="fc bfc" id="L1023" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1024">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if (referenceFrame == null) {</span>
<span class="nc" id="L1028">            referenceFrame = new ECEFFrame();</span>
        }

<span class="fc" id="L1031">        referenceFrame.setVelocity(referenceEcefVelocity);</span>
<span class="fc" id="L1032">    }</span>

    /**
     * Gets initial body coordinate transformation, containing body orientation
     * expressed in ECEF coordinates, before starting estimation.
     *
     * @return initial body orientation or null.
     */
    public CoordinateTransformation getReferenceEcefCoordinateTransformation() {
<span class="fc bfc" id="L1041" title="All 2 branches covered.">        return referenceFrame != null ?</span>
<span class="fc" id="L1042">                referenceFrame.getCoordinateTransformation() : null;</span>
    }

    /**
     * Gets initial body coordinate transformation, containing body orientation
     * expressed in ECEF coordinates, before starting estimation.
     *
     * @param result instance where the result will be stored.
     * @return true if initial body orientation was available and a result was
     * updated, false otherwise.
     * @throws NullPointerException if provided result instance is null.
     */
    public boolean getReferenceEcefCoordinateTransformation(final CoordinateTransformation result) {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L1056">            referenceFrame.getCoordinateTransformation(result);</span>
<span class="fc" id="L1057">            return true;</span>
        } else {
<span class="fc" id="L1059">            return false;</span>
        }
    }

    /**
     * Sets initial body coordinate transformation, containing body orientation
     * expressed in ECEF coordinates, before starting estimation.
     *
     * @param referenceEcefCoordinateTransformation initial body orientation.
     * @throws LockedException                               if estimator is already running.
     * @throws InvalidSourceAndDestinationFrameTypeException if source and
     *                                                       destination types are invalid. Source type must be
     *                                                       {@link com.irurueta.navigation.frames.FrameType#BODY_FRAME} and the destination
     *                                                       type must be {@link com.irurueta.navigation.frames.FrameType#EARTH_CENTERED_EARTH_FIXED_FRAME}
     *                                                       indicating that body orientation is expressed respect ECEF coordinates.
     * @throws NullPointerException                          if orientation is null.
     */
    public void setReferenceEcefCoordinateTransformation(
            final CoordinateTransformation referenceEcefCoordinateTransformation) throws LockedException,
            InvalidSourceAndDestinationFrameTypeException {
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1080">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1083" title="All 2 branches covered.">        if (referenceFrame == null) {</span>
<span class="fc" id="L1084">            referenceFrame = new ECEFFrame(referenceEcefCoordinateTransformation);</span>
        } else {
<span class="fc" id="L1086">            referenceFrame.setCoordinateTransformation(referenceEcefCoordinateTransformation);</span>
        }
<span class="fc" id="L1088">    }</span>

    /**
     * Gets initial body position, expressed in NED coordinates, before starting
     * drift estimation.
     *
     * @return initial body position or null.
     */
    public NEDPosition getReferenceNedPosition() {
<span class="fc" id="L1097">        final var nedFrame = getReferenceNedFrame();</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">        return nedFrame != null ? nedFrame.getPosition() : null;</span>
    }

    /**
     * Gets initial body position, expressed in NED coordinates, before starting
     * drift estimation.
     *
     * @param result instance where the result will be stored.
     * @return true if the initial body position was available and the result was updated,
     * false otherwise.
     * @throws NullPointerException if provided result instance is null.
     */
    public boolean getReferenceNedPosition(final NEDPosition result) {
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L1112">            final var nedFrame = getReferenceNedFrame();</span>
<span class="fc" id="L1113">            nedFrame.getPosition(result);</span>
<span class="fc" id="L1114">            return true;</span>
        } else {
<span class="fc" id="L1116">            return false;</span>
        }
    }

    /**
     * Sets initial body position, expressed in NED coordinates, before starting
     * drift estimation.
     *
     * @param referenceNedPosition initial body position.
     * @throws LockedException      if estimator is already running.
     * @throws NullPointerException if provided position is null.
     */
    public void setReferenceNedPosition(final NEDPosition referenceNedPosition) throws LockedException {
<span class="fc bfc" id="L1129" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1130">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1133" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L1134">            final var nedFrame = getReferenceNedFrame();</span>
<span class="fc" id="L1135">            nedFrame.setPosition(referenceNedPosition);</span>
<span class="fc" id="L1136">            setReferenceNedFrame(nedFrame);</span>
<span class="fc" id="L1137">        } else {</span>
<span class="fc" id="L1138">            setReferenceNedFrame(new NEDFrame(referenceNedPosition));</span>
        }
<span class="fc" id="L1140">    }</span>

    /**
     * Gets initial body velocity, expressed in NED coordinates, before starting
     * drift estimation.
     *
     * @return initial body velocity or null.
     */
    public NEDVelocity getReferenceNedVelocity() {
<span class="fc" id="L1149">        final var nedFrame = getReferenceNedFrame();</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">        return nedFrame != null ? nedFrame.getVelocity() : null;</span>
    }

    /**
     * Gets initial body velocity, expressed in NED coordinates, before starting
     * drift estimation.
     *
     * @param result instance where the result will be stored.
     * @return true if initial body velocity was available and the result was updated,
     * false otherwise.
     * @throws NullPointerException if provided result instance is null.
     */
    public boolean getReferenceNedVelocity(final NEDVelocity result) {
<span class="fc bfc" id="L1163" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L1164">            final var nedFrame = getReferenceNedFrame();</span>
<span class="fc" id="L1165">            nedFrame.getVelocity(result);</span>
<span class="fc" id="L1166">            return true;</span>
        } else {
<span class="fc" id="L1168">            return false;</span>
        }
    }

    /**
     * Sets initial body velocity, expressed in NED coordinates, before starting
     * drift estimation.
     *
     * @param referenceNedVelocity initial body velocity.
     * @throws LockedException      if estimator is already running.
     * @throws NullPointerException if velocity is null.
     */
    public void setReferenceNedVelocity(final NEDVelocity referenceNedVelocity) throws LockedException {
<span class="fc bfc" id="L1181" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1182">            throw new LockedException();</span>
        }

        final NEDFrame nedFrame;
<span class="fc bfc" id="L1186" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L1187">            nedFrame = getReferenceNedFrame();</span>
        } else {
<span class="fc" id="L1189">            nedFrame = new NEDFrame();</span>
        }

<span class="fc" id="L1192">        nedFrame.setVelocity(referenceNedVelocity);</span>
<span class="fc" id="L1193">        setReferenceNedFrame(nedFrame);</span>
<span class="fc" id="L1194">    }</span>

    /**
     * Gets initial body coordinate transformation, containing body orientation
     * expressed in NED coordinates, before starting estimation.
     *
     * @return initial body orientation or null.
     */
    public CoordinateTransformation getReferenceNedCoordinateTransformation() {
<span class="fc" id="L1203">        final var nedFrame = getReferenceNedFrame();</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">        return nedFrame != null ? nedFrame.getCoordinateTransformation() : null;</span>
    }

    /**
     * Gets initial body coordinate transformation, containing body orientation
     * expressed in NED coordinates, before starting estimation.
     *
     * @param result instance where the result will be stored.
     * @return true if initial body orientation was available and the result was
     * updated, false otherwise.
     * @throws NullPointerException if provided result instance is null.
     */
    public boolean getReferenceNedCoordinateTransformation(final CoordinateTransformation result) {
<span class="fc bfc" id="L1217" title="All 2 branches covered.">        if (referenceFrame != null) {</span>
<span class="fc" id="L1218">            final var nedFrame = getReferenceNedFrame();</span>
<span class="fc" id="L1219">            nedFrame.getCoordinateTransformation(result);</span>
<span class="fc" id="L1220">            return true;</span>
        } else {
<span class="fc" id="L1222">            return false;</span>
        }
    }

    /**
     * Sets initial body coordinate transformation, containing body orientation
     * expressed in NED coordinates, before starting estimation.
     *
     * @param referenceNedCoordinateTransformation initial body orientation.
     * @throws LockedException                               if estimator is already running.
     * @throws InvalidSourceAndDestinationFrameTypeException if source and
     *                                                       destination types are invalid. Source type must be
     *                                                       {@link com.irurueta.navigation.frames.FrameType#BODY_FRAME} and the destination
     *                                                       type must be {@link com.irurueta.navigation.frames.FrameType#LOCAL_NAVIGATION_FRAME}
     *                                                       indicating that body orientation is expressed respect NED coordinates.
     * @throws NullPointerException                          if orientation is null.
     */
    public void setReferenceNedCoordinateTransformation(
            final CoordinateTransformation referenceNedCoordinateTransformation) throws LockedException,
            InvalidSourceAndDestinationFrameTypeException {
<span class="fc bfc" id="L1242" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1243">            throw new LockedException();</span>
        }

        final NEDFrame nedFrame;
<span class="fc bfc" id="L1247" title="All 2 branches covered.">        if (referenceFrame == null) {</span>
<span class="fc" id="L1248">            nedFrame = new NEDFrame(referenceNedCoordinateTransformation);</span>
<span class="fc" id="L1249">            setReferenceNedFrame(nedFrame);</span>
        } else {
<span class="fc" id="L1251">            nedFrame = getReferenceNedFrame();</span>
<span class="fc" id="L1252">            nedFrame.setCoordinateTransformation(referenceNedCoordinateTransformation);</span>
        }
<span class="fc" id="L1254">    }</span>

    /**
     * Gets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @return bias values expressed in meters per squared second.
     */
    public Matrix getAccelerationBias() {
<span class="fc" id="L1262">        return fixer.getAccelerationBias();</span>
    }

    /**
     * Gets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBias(final Matrix result) {
<span class="fc" id="L1271">        fixer.getAccelerationBias(result);</span>
<span class="fc" id="L1272">    }</span>

    /**
     * Sets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @param bias bias values expressed in meters per squared second.
     *             Must be 3x1.
     * @throws LockedException          if estimator is running.
     * @throws IllegalArgumentException if any provided matrix is not 3x1.
     */
    public void setAccelerationBias(final Matrix bias) throws LockedException {
<span class="fc bfc" id="L1283" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1284">            throw new LockedException();</span>
        }

<span class="fc" id="L1287">        fixer.setAccelerationBias(bias);</span>
<span class="fc" id="L1288">    }</span>

    /**
     * Gets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @return bias values expressed in meters per squared second.
     */
    public double[] getAccelerationBiasArray() {
<span class="fc" id="L1296">        return fixer.getAccelerationBiasArray();</span>
    }

    /**
     * Gets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @param result instance where result data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAccelerationBiasArray(final double[] result) {
<span class="fc" id="L1306">        fixer.getAccelerationBiasArray(result);</span>
<span class="fc" id="L1307">    }</span>

    /**
     * Sets acceleration bias values expressed in meters per squared second (m/s^2).
     *
     * @param bias bias values expressed in meters per squared second (m/s^2).
     *             Must have length 3.
     * @throws IllegalArgumentException if provided array does not have length 3.
     * @throws LockedException          if estimator is running.
     */
    public void setAccelerationBias(final double[] bias) throws LockedException {
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1319">            throw new LockedException();</span>
        }

<span class="fc" id="L1322">        fixer.setAccelerationBias(bias);</span>
<span class="fc" id="L1323">    }</span>

    /**
     * Gets acceleration bias.
     *
     * @return acceleration bias.
     */
    public AccelerationTriad getAccelerationBiasAsTriad() {
<span class="fc" id="L1331">        return fixer.getAccelerationBiasAsTriad();</span>
    }

    /**
     * Gets acceleration bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBiasAsTriad(final AccelerationTriad result) {
<span class="fc" id="L1340">        fixer.getAccelerationBiasAsTriad(result);</span>
<span class="fc" id="L1341">    }</span>

    /**
     * Sets acceleration bias.
     *
     * @param bias acceleration bias to be set.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBias(final AccelerationTriad bias) throws LockedException {
<span class="fc bfc" id="L1350" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1351">            throw new LockedException();</span>
        }

<span class="fc" id="L1354">        fixer.setAccelerationBias(bias);</span>
<span class="fc" id="L1355">    }</span>

    /**
     * Gets acceleration x-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return x-coordinate of bias expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasX() {
<span class="fc" id="L1364">        return fixer.getAccelerationBiasX();</span>
    }

    /**
     * Sets acceleration x-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasX x-coordinate of bias expressed in meters per squared second
     *              (m/s^2).
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasX(final double biasX) throws LockedException {
<span class="fc bfc" id="L1376" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1377">            throw new LockedException();</span>
        }

<span class="fc" id="L1380">        fixer.setAccelerationBiasX(biasX);</span>
<span class="fc" id="L1381">    }</span>

    /**
     * Gets acceleration y-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return y-coordinate of bias expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasY() {
<span class="fc" id="L1390">        return fixer.getAccelerationBiasY();</span>
    }

    /**
     * Sets acceleration y-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasY y-coordinate of bias expressed in meters per squared second
     *              (m/s^2).
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasY(final double biasY) throws LockedException {
<span class="fc bfc" id="L1402" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1403">            throw new LockedException();</span>
        }

<span class="fc" id="L1406">        fixer.setAccelerationBiasY(biasY);</span>
<span class="fc" id="L1407">    }</span>

    /**
     * Gets acceleration z-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @return z-coordinate of bias expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasZ() {
<span class="fc" id="L1416">        return fixer.getAccelerationBiasZ();</span>
    }

    /**
     * Sets acceleration z-coordinate of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasZ z-coordinate of bias expressed in meters per squared second (m/s^2).
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasZ(final double biasZ) throws LockedException {
<span class="fc bfc" id="L1427" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1428">            throw new LockedException();</span>
        }

<span class="fc" id="L1431">        fixer.setAccelerationBiasZ(biasZ);</span>
<span class="fc" id="L1432">    }</span>

    /**
     * Sets acceleration coordinates of bias expressed in meters per squared
     * second (m/s^2).
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBias(final double biasX, final double biasY, final double biasZ) throws LockedException {
<span class="fc bfc" id="L1444" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1445">            throw new LockedException();</span>
        }

<span class="fc" id="L1448">        fixer.setAccelerationBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L1449">    }</span>

    /**
     * Gets acceleration x-coordinate of bias.
     *
     * @return acceleration x-coordinate of bias.
     */
    public Acceleration getAccelerationBiasXAsAcceleration() {
<span class="fc" id="L1457">        return fixer.getAccelerationBiasXAsAcceleration();</span>
    }

    /**
     * Gets acceleration x-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBiasXAsAcceleration(final Acceleration result) {
<span class="fc" id="L1466">        fixer.getAccelerationBiasXAsAcceleration(result);</span>
<span class="fc" id="L1467">    }</span>

    /**
     * Sets acceleration x-coordinate of bias.
     *
     * @param biasX acceleration x-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasX(final Acceleration biasX) throws LockedException {
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1477">            throw new LockedException();</span>
        }

<span class="fc" id="L1480">        fixer.setAccelerationBiasX(biasX);</span>
<span class="fc" id="L1481">    }</span>

    /**
     * Gets acceleration y-coordinate of bias.
     *
     * @return acceleration y-coordinate of bias.
     */
    public Acceleration getAccelerationBiasYAsAcceleration() {
<span class="fc" id="L1489">        return fixer.getAccelerationBiasYAsAcceleration();</span>
    }

    /**
     * Gets acceleration y-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBiasYAsAcceleration(final Acceleration result) {
<span class="fc" id="L1498">        fixer.getAccelerationBiasYAsAcceleration(result);</span>
<span class="fc" id="L1499">    }</span>

    /**
     * Sets acceleration y-coordinate of bias.
     *
     * @param biasY acceleration y-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasY(final Acceleration biasY) throws LockedException {
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1509">            throw new LockedException();</span>
        }

<span class="fc" id="L1512">        fixer.setAccelerationBiasY(biasY);</span>
<span class="fc" id="L1513">    }</span>

    /**
     * Gets acceleration z-coordinate of bias.
     *
     * @return acceleration z-coordinate of bias.
     */
    public Acceleration getAccelerationBiasZAsAcceleration() {
<span class="fc" id="L1521">        return fixer.getAccelerationBiasZAsAcceleration();</span>
    }

    /**
     * Gets acceleration z-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationBiasZAsAcceleration(final Acceleration result) {
<span class="fc" id="L1530">        fixer.getAccelerationBiasZAsAcceleration(result);</span>
<span class="fc" id="L1531">    }</span>

    /**
     * Sets acceleration z-coordinate of bias.
     *
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBiasZ(final Acceleration biasZ) throws LockedException {
<span class="fc bfc" id="L1540" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1541">            throw new LockedException();</span>
        }

<span class="fc" id="L1544">        fixer.setAccelerationBiasZ(biasZ);</span>
<span class="fc" id="L1545">    }</span>

    /**
     * Sets acceleration coordinates of bias.
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAccelerationBias(
            final Acceleration biasX,
            final Acceleration biasY,
            final Acceleration biasZ) throws LockedException {
<span class="fc bfc" id="L1559" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1560">            throw new LockedException();</span>
        }

<span class="fc" id="L1563">        fixer.setAccelerationBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L1564">    }</span>

    /**
     * Gets acceleration cross-coupling errors matrix.
     *
     * @return acceleration cross-coupling errors matrix.
     */
    public Matrix getAccelerationCrossCouplingErrors() {
<span class="fc" id="L1572">        return fixer.getAccelerationCrossCouplingErrors();</span>
    }

    /**
     * Gets acceleration cross-coupling errors matrix.
     *
     * @param result instance where the result will be stored.
     */
    public void getAccelerationCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L1581">        fixer.getAccelerationCrossCouplingErrors(result);</span>
<span class="fc" id="L1582">    }</span>

    /**
     * Sets acceleration cross-coupling errors matrix.
     *
     * @param crossCouplingErrors acceleration cross-coupling errors matrix.
     *                            Must be 3x3.
     * @throws LockedException          if estimator is running.
     * @throws AlgebraException         if matrix cannot be inverted.
     * @throws IllegalArgumentException if matrix is not 3x3.
     */
    public void setAccelerationCrossCouplingErrors(final Matrix crossCouplingErrors) throws AlgebraException,
            LockedException {
<span class="fc bfc" id="L1595" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1596">            throw new LockedException();</span>
        }

<span class="fc" id="L1599">        fixer.setAccelerationCrossCouplingErrors(crossCouplingErrors);</span>
<span class="fc" id="L1600">    }</span>

    /**
     * Gets acceleration x scaling factor.
     *
     * @return x scaling factor.
     */
    public double getAccelerationSx() {
<span class="fc" id="L1608">        return fixer.getAccelerationSx();</span>
    }

    /**
     * Sets acceleration x scaling factor.
     *
     * @param sx x scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationSx(final double sx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1619" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1620">            throw new LockedException();</span>
        }

<span class="fc" id="L1623">        fixer.setAccelerationSx(sx);</span>
<span class="fc" id="L1624">    }</span>

    /**
     * Gets acceleration y scaling factor.
     *
     * @return y scaling factor.
     */
    public double getAccelerationSy() {
<span class="fc" id="L1632">        return fixer.getAccelerationSy();</span>
    }

    /**
     * Sets acceleration y scaling factor.
     *
     * @param sy y scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationSy(final double sy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1643" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1644">            throw new LockedException();</span>
        }

<span class="fc" id="L1647">        fixer.setAccelerationSy(sy);</span>
<span class="fc" id="L1648">    }</span>

    /**
     * Gets acceleration z scaling factor.
     *
     * @return z scaling factor.
     */
    public double getAccelerationSz() {
<span class="fc" id="L1656">        return fixer.getAccelerationSz();</span>
    }

    /**
     * Sets acceleration z scaling factor.
     *
     * @param sz z scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationSz(final double sz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1667" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1668">            throw new LockedException();</span>
        }

<span class="fc" id="L1671">        fixer.setAccelerationSz(sz);</span>
<span class="fc" id="L1672">    }</span>

    /**
     * Gets acceleration x-y cross-coupling error.
     *
     * @return acceleration x-y cross-coupling error.
     */
    public double getAccelerationMxy() {
<span class="fc" id="L1680">        return fixer.getAccelerationMxy();</span>
    }

    /**
     * Sets acceleration x-y cross-coupling error.
     *
     * @param mxy acceleration x-y cross-coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMxy(final double mxy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1691" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1692">            throw new LockedException();</span>
        }

<span class="fc" id="L1695">        fixer.setAccelerationMxy(mxy);</span>
<span class="fc" id="L1696">    }</span>

    /**
     * Gets acceleration x-z cross-coupling error.
     *
     * @return acceleration x-z cross-coupling error.
     */
    public double getAccelerationMxz() {
<span class="fc" id="L1704">        return fixer.getAccelerationMxz();</span>
    }

    /**
     * Sets acceleration x-z cross-coupling error.
     *
     * @param mxz acceleration x-z cross-coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMxz(final double mxz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1715" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1716">            throw new LockedException();</span>
        }

<span class="fc" id="L1719">        fixer.setAccelerationMxz(mxz);</span>
<span class="fc" id="L1720">    }</span>

    /**
     * Gets acceleration y-x cross-coupling error.
     *
     * @return acceleration y-x cross-coupling error.
     */
    public double getAccelerationMyx() {
<span class="fc" id="L1728">        return fixer.getAccelerationMyx();</span>
    }

    /**
     * Sets acceleration y-x cross-coupling error.
     *
     * @param myx acceleration y-x cross-coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMyx(final double myx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1739" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1740">            throw new LockedException();</span>
        }

<span class="fc" id="L1743">        fixer.setAccelerationMyx(myx);</span>
<span class="fc" id="L1744">    }</span>

    /**
     * Gets acceleration y-z cross-coupling error.
     *
     * @return y-z cross coupling error.
     */
    public double getAccelerationMyz() {
<span class="fc" id="L1752">        return fixer.getAccelerationMyz();</span>
    }

    /**
     * Sets acceleration y-z cross-coupling error.
     *
     * @param myz y-z cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMyz(final double myz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1763" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1764">            throw new LockedException();</span>
        }

<span class="fc" id="L1767">        fixer.setAccelerationMyz(myz);</span>
<span class="fc" id="L1768">    }</span>

    /**
     * Gets acceleration z-x cross-coupling error.
     *
     * @return acceleration z-x cross-coupling error.
     */
    public double getAccelerationMzx() {
<span class="fc" id="L1776">        return fixer.getAccelerationMzx();</span>
    }

    /**
     * Sets acceleration z-x cross coupling error.
     *
     * @param mzx acceleration z-x cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMzx(final double mzx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1787" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1788">            throw new LockedException();</span>
        }

<span class="fc" id="L1791">        fixer.setAccelerationMzx(mzx);</span>
<span class="fc" id="L1792">    }</span>

    /**
     * Gets acceleration z-y cross-coupling error.
     *
     * @return acceleration z-y cross-coupling error.
     */
    public double getAccelerationMzy() {
<span class="fc" id="L1800">        return fixer.getAccelerationMzy();</span>
    }

    /**
     * Sets acceleration z-y cross-coupling error.
     *
     * @param mzy acceleration z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationMzy(final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1811" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1812">            throw new LockedException();</span>
        }

<span class="fc" id="L1815">        fixer.setAccelerationMzy(mzy);</span>
<span class="fc" id="L1816">    }</span>

    /**
     * Sets acceleration scaling factors.
     *
     * @param sx x scaling factor.
     * @param sy y scaling factor.
     * @param sz z scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationScalingFactors(final double sx, final double sy, final double sz)
            throws LockedException, AlgebraException {
<span class="fc bfc" id="L1829" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1830">            throw new LockedException();</span>
        }

<span class="fc" id="L1833">        fixer.setAccelerationScalingFactors(sx, sy, sz);</span>
<span class="fc" id="L1834">    }</span>

    /**
     * Sets acceleration cross-coupling errors.
     *
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationCrossCouplingErrors(
            final double mxy, final double mxz,
            final double myx, final double myz,
            final double mzx, final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1852" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1853">            throw new LockedException();</span>
        }

<span class="fc" id="L1856">        fixer.setAccelerationCrossCouplingErrors(mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L1857">    }</span>

    /**
     * Sets acceleration scaling factors and cross-coupling errors.
     *
     * @param sx  x scaling factor.
     * @param sy  y scaling factor.
     * @param sz  z scaling factor.
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make acceleration cross-coupling matrix non-invertible.
     */
    public void setAccelerationScalingFactorsAndCrossCouplingErrors(
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz,
            final double myx, final double myz,
            final double mzx, final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L1879" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1880">            throw new LockedException();</span>
        }

<span class="fc" id="L1883">        fixer.setAccelerationScalingFactorsAndCrossCouplingErrors(sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L1884">    }</span>

    /**
     * Gets angular speed bias values expressed in radians per second (rad/s).
     *
     * @return angular speed bias values expressed in radians per second.
     */
    public Matrix getAngularSpeedBias() {
<span class="fc" id="L1892">        return fixer.getAngularSpeedBias();</span>
    }

    /**
     * Gets angular speed bias values expressed in radians per second (rad/s).
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBias(final Matrix result) {
<span class="fc" id="L1901">        fixer.getAngularSpeedBias(result);</span>
<span class="fc" id="L1902">    }</span>

    /**
     * Sets angular speed bias values expressed in radians per second (rad/s).
     *
     * @param bias bias values expressed in radians per second. Must be 3x1.
     * @throws IllegalArgumentException if matrix is not 3x1.
     * @throws LockedException          if estimator is running.
     */
    public void setAngularSpeedBias(final Matrix bias) throws LockedException {
<span class="fc bfc" id="L1912" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1913">            throw new LockedException();</span>
        }

<span class="fc" id="L1916">        fixer.setAngularSpeedBias(bias);</span>
<span class="fc" id="L1917">    }</span>

    /**
     * Gets angular speed bias values expressed in radians per second (rad/s).
     *
     * @return bias values expressed in radians per second.
     */
    public double[] getAngularSpeedBiasArray() {
<span class="fc" id="L1925">        return fixer.getAngularSpeedBiasArray();</span>
    }

    /**
     * Gets angular speed bias values expressed in radians per second (rad/s).
     *
     * @param result instance where result data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAngularSpeedBiasArray(final double[] result) {
<span class="fc" id="L1935">        fixer.getAngularSpeedBiasArray(result);</span>
<span class="fc" id="L1936">    }</span>

    /**
     * Sets angular speed bias values expressed in radians per second (rad/s).
     *
     * @param bias bias values expressed in radians per second (rad/s). Must
     *             have length 3.
     * @throws IllegalArgumentException if provided array does not have length 3.
     * @throws LockedException          if estimator is running.
     */
    public void setAngularSpeedBias(final double[] bias) throws LockedException {
<span class="fc bfc" id="L1947" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1948">            throw new LockedException();</span>
        }

<span class="fc" id="L1951">        fixer.setAngularSpeedBias(bias);</span>
<span class="fc" id="L1952">    }</span>

    /**
     * Gets angular speed bias.
     *
     * @return angular speed bias.
     */
    public AngularSpeedTriad getAngularSpeedBiasAsTriad() {
<span class="fc" id="L1960">        return fixer.getAngularSpeedBiasAsTriad();</span>
    }

    /**
     * Gets angular speed bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBiasAsTriad(final AngularSpeedTriad result) {
<span class="fc" id="L1969">        fixer.getAngularSpeedBiasAsTriad(result);</span>
<span class="fc" id="L1970">    }</span>

    /**
     * Sets angular speed bias.
     *
     * @param bias angular speed bias to be set.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBias(final AngularSpeedTriad bias) throws LockedException {
<span class="fc bfc" id="L1979" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1980">            throw new LockedException();</span>
        }

<span class="fc" id="L1983">        fixer.setAngularSpeedBias(bias);</span>
<span class="fc" id="L1984">    }</span>

    /**
     * Gets angular speed x-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @return x-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getAngularSpeedBiasX() {
<span class="fc" id="L1993">        return fixer.getAngularSpeedBiasX();</span>
    }

    /**
     * Sets angular speed x-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @param biasX x-coordinate of bias expressed in radians per second (rad/s).
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasX(final double biasX) throws LockedException {
<span class="fc bfc" id="L2004" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2005">            throw new LockedException();</span>
        }

<span class="fc" id="L2008">        fixer.setAngularSpeedBiasX(biasX);</span>
<span class="fc" id="L2009">    }</span>

    /**
     * Gets angular speed y-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @return y-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getAngularSpeedBiasY() {
<span class="fc" id="L2018">        return fixer.getAngularSpeedBiasY();</span>
    }

    /**
     * Sets angular speed y-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @param biasY y-coordinate of bias expressed in radians per second (rad/s).
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasY(final double biasY) throws LockedException {
<span class="fc bfc" id="L2029" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2030">            throw new LockedException();</span>
        }

<span class="fc" id="L2033">        fixer.setAngularSpeedBiasY(biasY);</span>
<span class="fc" id="L2034">    }</span>

    /**
     * Gets angular speed z-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @return z-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getAngularSpeedBiasZ() {
<span class="fc" id="L2043">        return fixer.getAngularSpeedBiasZ();</span>
    }

    /**
     * Sets angular speed z-coordinate of bias expressed in radians per second
     * (rad/s).
     *
     * @param biasZ z-coordinate of bias expressed in radians per second (rad/s).
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasZ(final double biasZ) throws LockedException {
<span class="fc bfc" id="L2054" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2055">            throw new LockedException();</span>
        }

<span class="fc" id="L2058">        fixer.setAngularSpeedBiasZ(biasZ);</span>
<span class="fc" id="L2059">    }</span>

    /**
     * Sets angular speed coordinates of bias expressed in radians per second
     * (rad/s).
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBias(final double biasX, final double biasY, final double biasZ) throws LockedException {
<span class="fc bfc" id="L2071" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2072">            throw new LockedException();</span>
        }

<span class="fc" id="L2075">        fixer.setAngularSpeedBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L2076">    }</span>

    /**
     * Gets angular speed x-coordinate of bias.
     *
     * @return x-coordinate of bias.
     */
    public AngularSpeed getAngularSpeedBiasXAsAngularSpeed() {
<span class="fc" id="L2084">        return fixer.getAngularSpeedBiasXAsAngularSpeed();</span>
    }

    /**
     * Gets angular speed x-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBiasXAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2093">        fixer.getAngularSpeedBiasXAsAngularSpeed(result);</span>
<span class="fc" id="L2094">    }</span>

    /**
     * Sets angular speed x-coordinate of bias.
     *
     * @param biasX x-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasX(final AngularSpeed biasX) throws LockedException {
<span class="fc bfc" id="L2103" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2104">            throw new LockedException();</span>
        }

<span class="fc" id="L2107">        fixer.setAngularSpeedBiasX(biasX);</span>
<span class="fc" id="L2108">    }</span>

    /**
     * Gets angular speed y-coordinate of bias.
     *
     * @return y-coordinate of bias.
     */
    public AngularSpeed getAngularSpeedBiasYAsAngularSpeed() {
<span class="fc" id="L2116">        return fixer.getAngularSpeedBiasYAsAngularSpeed();</span>
    }

    /**
     * Gets angular speed y-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBiasYAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2125">        fixer.getAngularSpeedBiasYAsAngularSpeed(result);</span>
<span class="fc" id="L2126">    }</span>

    /**
     * Sets angular speed y-coordinate of bias.
     *
     * @param biasY y-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasY(final AngularSpeed biasY) throws LockedException {
<span class="fc bfc" id="L2135" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2136">            throw new LockedException();</span>
        }

<span class="fc" id="L2139">        fixer.setAngularSpeedBiasY(biasY);</span>
<span class="fc" id="L2140">    }</span>

    /**
     * Gets angular speed z-coordinate of bias.
     *
     * @return z-coordinate of bias.
     */
    public AngularSpeed getAngularSpeedBiasZAsAngularSpeed() {
<span class="fc" id="L2148">        return fixer.getAngularSpeedBiasZAsAngularSpeed();</span>
    }

    /**
     * Gets angular speed z-coordinate of bias.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedBiasZAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L2157">        fixer.getAngularSpeedBiasZAsAngularSpeed(result);</span>
<span class="fc" id="L2158">    }</span>

    /**
     * Sets angular speed z-coordinate of bias.
     *
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBiasZ(final AngularSpeed biasZ) throws LockedException {
<span class="fc bfc" id="L2167" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2168">            throw new LockedException();</span>
        }

<span class="fc" id="L2171">        fixer.setAngularSpeedBiasZ(biasZ);</span>
<span class="fc" id="L2172">    }</span>

    /**
     * Sets angular speed coordinates of bias.
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     * @throws LockedException if estimator is running.
     */
    public void setAngularSpeedBias(
            final AngularSpeed biasX,
            final AngularSpeed biasY,
            final AngularSpeed biasZ) throws LockedException {
<span class="fc bfc" id="L2186" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2187">            throw new LockedException();</span>
        }

<span class="fc" id="L2190">        fixer.setAngularSpeedBias(biasX, biasY, biasZ);</span>
<span class="fc" id="L2191">    }</span>

    /**
     * Gets angular speed cross-coupling errors matrix.
     *
     * @return cross coupling errors matrix.
     */
    public Matrix getAngularSpeedCrossCouplingErrors() {
<span class="fc" id="L2199">        return fixer.getAngularSpeedCrossCouplingErrors();</span>
    }

    /**
     * Gets angular speed cross-coupling errors matrix.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L2208">        fixer.getAngularSpeedCrossCouplingErrors(result);</span>
<span class="fc" id="L2209">    }</span>

    /**
     * Sets angular speed cross-coupling errors matrix.
     *
     * @param crossCouplingErrors cross-coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if matrix cannot be inverted.
     * @throws IllegalArgumentException if matrix is not 3x3.
     * @throws LockedException          if estimator is running.
     */
    public void setAngularSpeedCrossCouplingErrors(final Matrix crossCouplingErrors) throws AlgebraException,
            LockedException {
<span class="fc bfc" id="L2221" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2222">            throw new LockedException();</span>
        }

<span class="fc" id="L2225">        fixer.setAngularSpeedCrossCouplingErrors(crossCouplingErrors);</span>
<span class="fc" id="L2226">    }</span>

    /**
     * Gets angular speed x scaling factor.
     *
     * @return x scaling factor.
     */
    public double getAngularSpeedSx() {
<span class="fc" id="L2234">        return fixer.getAngularSpeedSx();</span>
    }

    /**
     * Sets angular speed x scaling factor.
     *
     * @param sx x scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedSx(final double sx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2246" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2247">            throw new LockedException();</span>
        }

<span class="fc" id="L2250">        fixer.setAngularSpeedSx(sx);</span>
<span class="fc" id="L2251">    }</span>

    /**
     * Gets angular speed y scaling factor.
     *
     * @return y scaling factor.
     */
    public double getAngularSpeedSy() {
<span class="fc" id="L2259">        return fixer.getAngularSpeedSy();</span>
    }

    /**
     * Sets angular speed y-scaling factor.
     *
     * @param sy y scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedSy(final double sy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2271" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2272">            throw new LockedException();</span>
        }

<span class="fc" id="L2275">        fixer.setAngularSpeedSy(sy);</span>
<span class="fc" id="L2276">    }</span>

    /**
     * Gets angular speed z scaling factor.
     *
     * @return z scaling factor.
     */
    public double getAngularSpeedSz() {
<span class="fc" id="L2284">        return fixer.getAngularSpeedSz();</span>
    }

    /**
     * Sets angular speed z scaling factor.
     *
     * @param sz z scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedSz(final double sz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2296" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2297">            throw new LockedException();</span>
        }

<span class="fc" id="L2300">        fixer.setAngularSpeedSz(sz);</span>
<span class="fc" id="L2301">    }</span>

    /**
     * Gets angular speed x-y cross-coupling error.
     *
     * @return x-y cross coupling error.
     */
    public double getAngularSpeedMxy() {
<span class="fc" id="L2309">        return fixer.getAngularSpeedMxy();</span>
    }

    /**
     * Sets angular speed x-y cross-coupling error.
     *
     * @param mxy x-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMxy(final double mxy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2321" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2322">            throw new LockedException();</span>
        }

<span class="fc" id="L2325">        fixer.setAngularSpeedMxy(mxy);</span>
<span class="fc" id="L2326">    }</span>

    /**
     * Gets angular speed x-z cross-coupling error.
     *
     * @return x-z cross coupling error.
     */
    public double getAngularSpeedMxz() {
<span class="fc" id="L2334">        return fixer.getAngularSpeedMxz();</span>
    }

    /**
     * Sets angular speed x-z cross-coupling error.
     *
     * @param mxz x-z cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMxz(final double mxz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2346" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2347">            throw new LockedException();</span>
        }

<span class="fc" id="L2350">        fixer.setAngularSpeedMxz(mxz);</span>
<span class="fc" id="L2351">    }</span>

    /**
     * Gets angular speed y-x cross-coupling error.
     *
     * @return y-x cross coupling error.
     */
    public double getAngularSpeedMyx() {
<span class="fc" id="L2359">        return fixer.getAngularSpeedMyx();</span>
    }

    /**
     * Sets angular speed y-x cross-coupling error.
     *
     * @param myx y-x cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMyx(final double myx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2371" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2372">            throw new LockedException();</span>
        }

<span class="fc" id="L2375">        fixer.setAngularSpeedMyx(myx);</span>
<span class="fc" id="L2376">    }</span>

    /**
     * Gets angular speed y-z cross-coupling error.
     *
     * @return y-z cross coupling error.
     */
    public double getAngularSpeedMyz() {
<span class="fc" id="L2384">        return fixer.getAngularSpeedMyz();</span>
    }

    /**
     * Sets angular speed y-z cross-coupling error.
     *
     * @param myz y-z cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMyz(final double myz) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2396" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2397">            throw new LockedException();</span>
        }

<span class="fc" id="L2400">        fixer.setAngularSpeedMyz(myz);</span>
<span class="fc" id="L2401">    }</span>

    /**
     * Gets angular speed z-x cross-coupling error.
     *
     * @return z-x cross coupling error.
     */
    public double getAngularSpeedMzx() {
<span class="fc" id="L2409">        return fixer.getAngularSpeedMzx();</span>
    }

    /**
     * Sets angular speed z-x cross-coupling error.
     *
     * @param mzx z-x cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMzx(final double mzx) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2421" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2422">            throw new LockedException();</span>
        }

<span class="fc" id="L2425">        fixer.setAngularSpeedMzx(mzx);</span>
<span class="fc" id="L2426">    }</span>

    /**
     * Gets angular speed z-y cross-coupling error.
     *
     * @return z-y cross coupling error.
     */
    public double getAngularSpeedMzy() {
<span class="fc" id="L2434">        return fixer.getAngularSpeedMzy();</span>
    }

    /**
     * Sets angular speed z-y cross-coupling error.
     *
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided value makes angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedMzy(final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2446" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2447">            throw new LockedException();</span>
        }

<span class="fc" id="L2450">        fixer.setAngularSpeedMzy(mzy);</span>
<span class="fc" id="L2451">    }</span>

    /**
     * Sets angular speed scaling factors.
     *
     * @param sx x scaling factor.
     * @param sy y scaling factor.
     * @param sz z scaling factor.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedScalingFactors(final double sx, final double sy, final double sz) throws LockedException,
            AlgebraException {
<span class="fc bfc" id="L2465" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2466">            throw new LockedException();</span>
        }

<span class="fc" id="L2469">        fixer.setAngularSpeedScalingFactors(sx, sy, sz);</span>
<span class="fc" id="L2470">    }</span>

    /**
     * Sets angular speed cross-coupling errors.
     *
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedCrossCouplingErrors(
            final double mxy, final double mxz,
            final double myx, final double myz,
            final double mzx, final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2489" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2490">            throw new LockedException();</span>
        }

<span class="fc" id="L2493">        fixer.setAngularSpeedCrossCouplingErrors(mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2494">    }</span>

    /**
     * Sets angular speed scaling factors and cross-coupling errors.
     *
     * @param sx  x scaling factor.
     * @param sy  y scaling factor.
     * @param sz  z scaling factor.
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws LockedException  if estimator is running.
     * @throws AlgebraException if provided values make angular speed
     *                          cross-coupling matrix non-invertible.
     */
    public void setAngularSpeedScalingFactorsAndCrossCouplingErrors(
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz,
            final double myx, final double myz,
            final double mzx, final double mzy) throws LockedException, AlgebraException {
<span class="fc bfc" id="L2517" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2518">            throw new LockedException();</span>
        }

<span class="fc" id="L2521">        fixer.setAngularSpeedScalingFactorsAndCrossCouplingErrors(sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy);</span>
<span class="fc" id="L2522">    }</span>

    /**
     * Gets angular speed g-dependant cross biases matrix.
     *
     * @return g-dependant cross biases matrix.
     */
    public Matrix getAngularSpeedGDependantCrossBias() {
<span class="fc" id="L2530">        return fixer.getAngularSpeedGDependantCrossBias();</span>
    }

    /**
     * Gets angular speed g-dependant cross biases matrix.
     *
     * @param result instance where the result will be stored.
     */
    public void getAngularSpeedGDependantCrossBias(final Matrix result) {
<span class="fc" id="L2539">        fixer.getAngularSpeedGDependantCrossBias(result);</span>
<span class="fc" id="L2540">    }</span>

    /**
     * Sets angular speed g-dependant cross biases matrix.
     *
     * @param gDependantCrossBias g-dependant cross biases matrix.
     * @throws IllegalArgumentException if matrix is not 3x3.
     * @throws LockedException          if estimator is running.
     */
    public void setAngularSpeedGDependantCrossBias(final Matrix gDependantCrossBias) throws LockedException {
<span class="fc bfc" id="L2550" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2551">            throw new LockedException();</span>
        }

<span class="fc" id="L2554">        fixer.setAngularSpeedGDependantCrossBias(gDependantCrossBias);</span>
<span class="fc" id="L2555">    }</span>

    /**
     * Indicates whether measured kinematics must be fixed or not.
     * When enabled, provided calibration data is used; otherwise it is
     * ignored.
     * By default, this is enabled.
     *
     * @return indicates whether measured kinematics must be fixed or not.
     */
    public boolean isFixKinematicsEnabled() {
<span class="fc" id="L2566">        return fixKinematics;</span>
    }

    /**
     * Specifies whether measured kinematics must be fixed or not.
     * When enabled, provided calibration data is used; otherwise it is
     * ignored.
     *
     * @param fixKinematics true if measured kinematics must be fixed or not.
     * @throws LockedException if estimator is currently running.
     */
    public void setFixKinematicsEnabled(final boolean fixKinematics) throws LockedException {
<span class="fc bfc" id="L2578" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2579">            throw new LockedException();</span>
        }
<span class="fc" id="L2581">        this.fixKinematics = fixKinematics;</span>
<span class="fc" id="L2582">    }</span>

    /**
     * Gets the time interval between body kinematics (IMU acceleration and gyroscope)
     * samples expressed in seconds (s).
     *
     * @return time interval between body kinematics samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L2591">        return timeInterval;</span>
    }

    /**
     * Sets a time interval between body kinematics (IMU acceleration and gyroscope)
     * samples expressed in seconds (s).
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L2602" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L2603">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L2606" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L2607">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L2610">        this.timeInterval = timeInterval;</span>
<span class="fc" id="L2611">    }</span>

    /**
     * Gets time interval between body kinematics (IMU acceleration and gyroscope)
     * samples.
     *
     * @return time interval between body kinematics samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L2620">        return new Time(timeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between body kinematics (IMU acceleration and gyroscope)
     * samples.
     *
     * @param result instance where the time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L2630">        result.setValue(timeInterval);</span>
<span class="fc" id="L2631">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L2632">    }</span>

    /**
     * Sets time interval between body kinematics (IMU acceleration and gyroscope)
     * samples.
     *
     * @param timeInterval time interval between body kinematics samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L2642">        setTimeInterval(convertTime(timeInterval));</span>
<span class="fc" id="L2643">    }</span>

    /**
     * Indicates if estimator is ready to start processing additional kinematics
     * measurements.
     *
     * @return true if ready, false otherwise.
     */
    public boolean isReady() {
<span class="fc bfc" id="L2652" title="All 2 branches covered.">        return referenceFrame != null;</span>
    }

    /**
     * Indicates whether this estimator is running.
     *
     * @return true if this estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L2661">        return running;</span>
    }

    /**
     * Adds a sample of measured body kinematics (accelerometer and gyroscope readings)
     * obtained from an IMU, fixes their values and uses fixed values to estimate
     * current drift and their average values.
     *
     * @param kinematics measured body kinematics.
     * @throws LockedException          if estimator is currently running.
     * @throws NotReadyException        if estimator is not ready.
     * @throws DriftEstimationException if estimation fails for some reason.
     */
    public void addBodyKinematics(final BodyKinematics kinematics) throws LockedException, NotReadyException,
            DriftEstimationException {
<span class="pc bpc" id="L2676" title="1 of 2 branches missed.">        if (running) {</span>
<span class="nc" id="L2677">            throw new LockedException();</span>
        }

<span class="pc bpc" id="L2680" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L2681">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L2685">            running = true;</span>

<span class="fc bfc" id="L2687" title="All 2 branches covered.">            if (numberOfProcessedSamples == 0) {</span>
<span class="fc bfc" id="L2688" title="All 2 branches covered.">                if (listener != null) {</span>
<span class="fc" id="L2689">                    listener.onStart(this);</span>
                }

<span class="fc" id="L2692">                final var c = referenceFrame.getCoordinateTransformation();</span>
<span class="fc" id="L2693">                c.asRotation(refQ);</span>
<span class="fc" id="L2694">                refQ.inverse(invRefQ);</span>

<span class="fc" id="L2696">                frame.copyFrom(referenceFrame);</span>
            }

<span class="fc bfc" id="L2699" title="All 2 branches covered.">            if (fixKinematics) {</span>
<span class="fc" id="L2700">                fixer.fix(kinematics, fixedKinematics);</span>
            } else {
<span class="fc" id="L2702">                fixedKinematics.copyFrom(kinematics);</span>
            }

            // estimate navigation variation respect to previous frame
<span class="fc" id="L2706">            ECEFInertialNavigator.navigateECEF(timeInterval, frame, fixedKinematics, frame);</span>

            // estimate drift values
<span class="fc" id="L2709">            computeCurrentPositionDrift();</span>
<span class="fc" id="L2710">            computeCurrentVelocityDrift();</span>
<span class="fc" id="L2711">            computeCurrentOrientationDrift();</span>

<span class="fc" id="L2713">            numberOfProcessedSamples++;</span>

<span class="fc bfc" id="L2715" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L2716">                listener.onBodyKinematicsAdded(this, kinematics, fixedKinematics);</span>
            }

<span class="nc" id="L2719">        } catch (final AlgebraException | InertialNavigatorException | InvalidRotationMatrixException e) {</span>
<span class="nc" id="L2720">            throw new DriftEstimationException(e);</span>
        } finally {
<span class="fc" id="L2722">            running = false;</span>
        }
<span class="fc" id="L2724">    }</span>

    /**
     * Resets this estimator to its initial state.
     *
     * @throws LockedException if estimator is currently running.
     */
    public void reset() throws LockedException {
<span class="pc bpc" id="L2732" title="1 of 2 branches missed.">        if (running) {</span>
<span class="nc" id="L2733">            throw new LockedException();</span>
        }

<span class="fc" id="L2736">        running = true;</span>
<span class="fc" id="L2737">        numberOfProcessedSamples = 0;</span>

<span class="fc" id="L2739">        currentPositionDriftMeters = 0.0;</span>
<span class="fc" id="L2740">        currentVelocityDriftMetersPerSecond = 0.0;</span>
<span class="fc" id="L2741">        currentOrientationDriftRadians = 0.0;</span>

<span class="fc bfc" id="L2743" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L2744">            listener.onReset(this);</span>
        }

<span class="fc" id="L2747">        running = false;</span>
<span class="fc" id="L2748">    }</span>

    /**
     * Gets the number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L2756">        return numberOfProcessedSamples;</span>
    }

    /**
     * Gets elapsed time since the first processed measurement expressed in seconds.
     *
     * @return elapsed time.
     */
    public double getElapsedTimeSeconds() {
<span class="fc" id="L2765">        return numberOfProcessedSamples * timeInterval;</span>
    }

    /**
     * Gets elapsed time since the first processed measurement.
     *
     * @return elapsed time.
     */
    public Time getElapsedTime() {
<span class="fc bfc" id="L2774" title="All 2 branches covered.">        return numberOfProcessedSamples &gt; 0 ? new Time(getElapsedTimeSeconds(), TimeUnit.SECOND) : null;</span>
    }

    /**
     * Gets elapsed time since the first processed measurement.
     *
     * @param result instance where the result will be stored.
     * @return true if elapsed time is available and the result is updated,
     * false otherwise.
     */
    public boolean getElapsedTime(final Time result) {
<span class="fc bfc" id="L2785" title="All 2 branches covered.">        if (numberOfProcessedSamples &gt; 0) {</span>
<span class="fc" id="L2786">            result.setValue(getElapsedTimeSeconds());</span>
<span class="fc" id="L2787">            result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L2788">            return true;</span>
        } else {
<span class="fc" id="L2790">            return false;</span>
        }
    }

    /**
     * Gets current position drift for last processed body kinematics
     * measurement expressed in meters (m) respect ECEF coordinates.
     *
     * @return current position drift or null.
     */
    public ECEFPosition getCurrentPositionDrift() {
<span class="fc bfc" id="L2801" title="All 2 branches covered.">        return numberOfProcessedSamples &gt; 0 ? new ECEFPosition(currentPositionDrift) : null;</span>
    }

    /**
     * Gets current position drift for last processed body kinematics
     * measurement expressed in meters (m) respect ECEF coordinates.
     *
     * @param result instance where the result will be stored.
     * @return true if the current position drift is available and the result is updated,
     * false otherwise.
     */
    public boolean getCurrentPositionDrift(final ECEFPosition result) {
<span class="fc bfc" id="L2813" title="All 2 branches covered.">        if (numberOfProcessedSamples &gt; 0) {</span>
<span class="fc" id="L2814">            result.copyFrom(currentPositionDrift);</span>
<span class="fc" id="L2815">            return true;</span>
        } else {
<span class="fc" id="L2817">            return false;</span>
        }
    }

    /**
     * Gets current velocity drift for the last processed body kinematics
     * measurement expressed in meters per second (m/s) respect ECEF coordinates.
     *
     * @return current velocity drift or null.
     */
    public ECEFVelocity getCurrentVelocityDrift() {
<span class="fc bfc" id="L2828" title="All 2 branches covered.">        return numberOfProcessedSamples &gt; 0 ? new ECEFVelocity(currentVelocityDrift) : null;</span>
    }

    /**
     * Gets current velocity drift for the last processed body kinematics
     * measurement expressed in meters per second (m/s) respect ECEF coordinates.
     *
     * @param result instance where the result will be stored.
     * @return true if the current velocity drift is available and the result is updated,
     * false otherwise.
     */
    public boolean getCurrentVelocityDrift(final ECEFVelocity result) {
<span class="fc bfc" id="L2840" title="All 2 branches covered.">        if (numberOfProcessedSamples &gt; 0) {</span>
<span class="fc" id="L2841">            result.copyFrom(currentVelocityDrift);</span>
<span class="fc" id="L2842">            return true;</span>
        } else {
<span class="fc" id="L2844">            return false;</span>
        }
    }

    /**
     * Gets current orientation drift as a 3D rotation for the last processed body
     * kinematics measurement respect ECEF coordinates.
     *
     * @return current orientation drift or null.
     */
    public Rotation3D getCurrentOrientationDrift() {
<span class="fc bfc" id="L2855" title="All 2 branches covered.">        return numberOfProcessedSamples &gt; 0 ? new Quaternion(q) : null;</span>
    }

    /**
     * Gets current orientation drift as a 3D rotation for the last processed body
     * kinematics measurement respect ECEF coordinates.
     *
     * @param result instance where the result will be stored.
     * @return true if the current orientation drift is available and the result is
     * updated, false otherwise.
     */
    public boolean getCurrentOrientationDrift(final Rotation3D result) {
<span class="fc bfc" id="L2867" title="All 2 branches covered.">        if (numberOfProcessedSamples &gt; 0) {</span>
<span class="fc" id="L2868">            result.fromRotation(q);</span>
<span class="fc" id="L2869">            return true;</span>
        } else {
<span class="fc" id="L2871">            return false;</span>
        }
    }

    /**
     * Gets current amount of position drift for last processed body kinematics
     * measurement expressed in meters (m).
     *
     * @return the current amount of position drift or null.
     */
    public Double getCurrentPositionDriftNormMeters() {
<span class="fc bfc" id="L2882" title="All 2 branches covered.">        return numberOfProcessedSamples &gt; 0 ? currentPositionDriftMeters : null;</span>
    }

    /**
     * Gets current amount of position drift for last processed body kinematics
     * measurement.
     *
     * @return the current amount of position drift or null.
     */
    public Distance getCurrentPositionDriftNorm() {
<span class="fc" id="L2892">        final var positionDrift = getCurrentPositionDriftNormMeters();</span>
<span class="fc bfc" id="L2893" title="All 2 branches covered.">        return positionDrift != null ? new Distance(positionDrift, DistanceUnit.METER) : null;</span>
    }

    /**
     * Gets current amount of position drift for last processed body kinematics
     * measurement.
     *
     * @param result instance where the result will be stored.
     * @return true if the current position drift is available and the result is updated,
     * false otherwise.
     */
    public boolean getCurrentPositionDriftNorm(final Distance result) {
<span class="fc" id="L2905">        final var positionDrift = getCurrentPositionDriftNormMeters();</span>
<span class="fc bfc" id="L2906" title="All 2 branches covered.">        if (positionDrift != null) {</span>
<span class="fc" id="L2907">            result.setValue(positionDrift);</span>
<span class="fc" id="L2908">            result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L2909">            return true;</span>
        } else {
<span class="fc" id="L2911">            return false;</span>
        }
    }

    /**
     * Gets current amount of velocity drift for the last processed body kinematics
     * measurement expressed in meters per second (m/s).
     *
     * @return current amount of velocity drift or null.
     */
    public Double getCurrentVelocityDriftNormMetersPerSecond() {
<span class="fc bfc" id="L2922" title="All 2 branches covered.">        return numberOfProcessedSamples &gt; 0 ? currentVelocityDriftMetersPerSecond : null;</span>
    }

    /**
     * Gets current amount of velocity drift for last processed body kinematics
     * measurement.
     *
     * @return current amount of velocity drift or null.
     */
    public Speed getCurrentVelocityDriftNorm() {
<span class="fc" id="L2932">        final var velocityDrift = getCurrentVelocityDriftNormMetersPerSecond();</span>
<span class="fc bfc" id="L2933" title="All 2 branches covered.">        return velocityDrift != null ? new Speed(velocityDrift, SpeedUnit.METERS_PER_SECOND) : null;</span>
    }

    /**
     * Gets current amount of velocity drift for last processed body kinematics
     * measurement.
     *
     * @param result instance where the result will be stored.
     * @return true if the current velocity drift is available and the result is updated,
     * false otherwise.
     */
    public boolean getCurrentVelocityDriftNorm(final Speed result) {
<span class="fc" id="L2945">        final var velocityDrift = getCurrentVelocityDriftNormMetersPerSecond();</span>
<span class="fc bfc" id="L2946" title="All 2 branches covered.">        if (velocityDrift != null) {</span>
<span class="fc" id="L2947">            result.setValue(velocityDrift);</span>
<span class="fc" id="L2948">            result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L2949">            return true;</span>
        } else {
<span class="fc" id="L2951">            return false;</span>
        }
    }

    /**
     * Gets current amount of orientation drift for last processed body kinematics
     * measurement expressed in radians (rad).
     *
     * @return current amount of orientation drift or null.
     */
    public Double getCurrentOrientationDriftRadians() {
<span class="fc bfc" id="L2962" title="All 2 branches covered.">        return numberOfProcessedSamples &gt; 0 ? currentOrientationDriftRadians : null;</span>
    }

    /**
     * Gets current amount of orientation drift for last processed body kinematics
     * measurement.
     *
     * @return current amount of orientation drift or null.
     */
    public Angle getCurrentOrientationDriftAngle() {
<span class="fc" id="L2972">        final var orientationDrift = getCurrentOrientationDriftRadians();</span>
<span class="fc bfc" id="L2973" title="All 2 branches covered.">        return orientationDrift != null ? new Angle(orientationDrift, AngleUnit.RADIANS) : null;</span>
    }

    /**
     * Gets current amount of orientation drift for last processed body kinematics
     * measurement.
     *
     * @param result instance where the result will be stored.
     * @return true if the current orientation drift is available and the result is
     * updated, false otherwise.
     */
    public boolean getCurrentOrientationDriftAngle(final Angle result) {
<span class="fc" id="L2985">        final var orientationDrift = getCurrentOrientationDriftRadians();</span>
<span class="fc bfc" id="L2986" title="All 2 branches covered.">        if (orientationDrift != null) {</span>
<span class="fc" id="L2987">            result.setValue(orientationDrift);</span>
<span class="fc" id="L2988">            result.setUnit(AngleUnit.RADIANS);</span>
<span class="fc" id="L2989">            return true;</span>
        } else {
<span class="fc" id="L2991">            return false;</span>
        }
    }

    /**
     * Gets the current amount of position drift per time unit expressed in meters
     * per second (m/s).
     *
     * @return current amount of position drift per time unit or null.
     */
    public Double getCurrentPositionDriftPerTimeUnit() {
<span class="fc" id="L3002">        final var positionDrift = getCurrentPositionDriftNormMeters();</span>
<span class="fc" id="L3003">        final var elapsedTime = getElapsedTimeSeconds();</span>
<span class="fc bfc" id="L3004" title="All 2 branches covered.">        return positionDrift != null ? positionDrift / elapsedTime : null;</span>
    }

    /**
     * Gets the current amount of position drift per time unit.
     *
     * @return current amount of position drift per time unit or null.
     */
    public Speed getCurrentPositionDriftPerTimeUnitAsSpeed() {
<span class="fc" id="L3013">        final var positionDriftPerTimeUnit = getCurrentPositionDriftPerTimeUnit();</span>
<span class="fc bfc" id="L3014" title="All 2 branches covered.">        return positionDriftPerTimeUnit != null ? new Speed(positionDriftPerTimeUnit, SpeedUnit.METERS_PER_SECOND)</span>
<span class="fc" id="L3015">                : null;</span>
    }

    /**
     * Gets the current amount of position drift per time unit.
     *
     * @param result instance where the result will be stored.
     * @return true if the current amount of position drift per time unit is
     * available and the result is updated, false otherwise.
     */
    public boolean getCurrentPositionDriftPerTimeUnitAsSpeed(final Speed result) {
<span class="fc" id="L3026">        final var positionDriftPerTimeUnit = getCurrentPositionDriftPerTimeUnit();</span>
<span class="fc bfc" id="L3027" title="All 2 branches covered.">        if (positionDriftPerTimeUnit != null) {</span>
<span class="fc" id="L3028">            result.setValue(positionDriftPerTimeUnit);</span>
<span class="fc" id="L3029">            result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L3030">            return true;</span>
        } else {
<span class="fc" id="L3032">            return false;</span>
        }
    }

    /**
     * Gets the current amount of velocity drift per time unit expressed in meters
     * per squared second (m/s^2).
     *
     * @return the current amount of velocity drift per time unit or null.
     */
    public Double getCurrentVelocityDriftPerTimeUnit() {
<span class="fc" id="L3043">        final var velocityDrift = getCurrentVelocityDriftNormMetersPerSecond();</span>
<span class="fc" id="L3044">        final var elapsedTime = getElapsedTimeSeconds();</span>
<span class="fc bfc" id="L3045" title="All 2 branches covered.">        return velocityDrift != null ? velocityDrift / elapsedTime : null;</span>
    }

    /**
     * Gets the current amount of velocity drift per time unit.
     *
     * @return the current amount of velocity drift per time unit or null.
     */
    public Acceleration getCurrentVelocityDriftPerTimeUnitAsAcceleration() {
<span class="fc" id="L3054">        final var velocityDriftPerTimeUnit = getCurrentVelocityDriftPerTimeUnit();</span>
<span class="fc bfc" id="L3055" title="All 2 branches covered.">        return velocityDriftPerTimeUnit != null</span>
<span class="fc" id="L3056">                ? new Acceleration(velocityDriftPerTimeUnit, AccelerationUnit.METERS_PER_SQUARED_SECOND) : null;</span>
    }

    /**
     * Gets the current amount of velocity drift per time unit.
     *
     * @param result instance where the result will be stored.
     * @return true if the current amount of velocity drift per time unit is available
     * and the result is updated, false otherwise.
     */
    public boolean getCurrentVelocityDriftPerTimeUnitAsAcceleration(final Acceleration result) {
<span class="fc" id="L3067">        final var velocityDriftPerTimeUnit = getCurrentVelocityDriftPerTimeUnit();</span>
<span class="fc bfc" id="L3068" title="All 2 branches covered.">        if (velocityDriftPerTimeUnit != null) {</span>
<span class="fc" id="L3069">            result.setValue(velocityDriftPerTimeUnit);</span>
<span class="fc" id="L3070">            result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L3071">            return true;</span>
        } else {
<span class="fc" id="L3073">            return false;</span>
        }
    }

    /**
     * Gets the current amount of orientation drift per time unit expressed in radians
     * per second (rad/s).
     *
     * @return amount of orientation drift per time unit or null.
     */
    public Double getCurrentOrientationDriftPerTimeUnit() {
<span class="fc" id="L3084">        final var orientationDrift = getCurrentOrientationDriftRadians();</span>
<span class="fc" id="L3085">        final var elapsedTime = getElapsedTimeSeconds();</span>
<span class="fc bfc" id="L3086" title="All 2 branches covered.">        return orientationDrift != null ? orientationDrift / elapsedTime : null;</span>
    }

    /**
     * Gets the current amount of orientation drift per time unit.
     *
     * @return amount of orientation drift per time unit or null.
     */
    public AngularSpeed getCurrentOrientationDriftPerTimeUnitAsAngularSpeed() {
<span class="fc" id="L3095">        final var orientationDriftPerTimeUnit = getCurrentOrientationDriftPerTimeUnit();</span>
<span class="fc bfc" id="L3096" title="All 2 branches covered.">        return orientationDriftPerTimeUnit != null ?</span>
<span class="fc" id="L3097">                new AngularSpeed(orientationDriftPerTimeUnit, AngularSpeedUnit.RADIANS_PER_SECOND) : null;</span>
    }

    /**
     * Gets the current amount of orientation drift per time unit.
     *
     * @param result instance where the result will be stored.
     * @return true if the current amount of orientation drift is available and the result
     * is updated, false otherwise.
     */
    public boolean getCurrentOrientationDriftPerTimeUnitAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L3108">        final var orientationDriftPerTimeUnit = getCurrentOrientationDriftPerTimeUnit();</span>
<span class="fc bfc" id="L3109" title="All 2 branches covered.">        if (orientationDriftPerTimeUnit != null) {</span>
<span class="fc" id="L3110">            result.setValue(orientationDriftPerTimeUnit);</span>
<span class="fc" id="L3111">            result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L3112">            return true;</span>
        } else {
<span class="fc" id="L3114">            return false;</span>
        }
    }

    /**
     * Computes current position drift.
     */
    protected void computeCurrentPositionDrift() {
<span class="fc" id="L3122">        final var initX = referenceFrame.getX();</span>
<span class="fc" id="L3123">        final var initY = referenceFrame.getY();</span>
<span class="fc" id="L3124">        final var initZ = referenceFrame.getZ();</span>

<span class="fc" id="L3126">        final var currentX = frame.getX();</span>
<span class="fc" id="L3127">        final var currentY = frame.getY();</span>
<span class="fc" id="L3128">        final var currentZ = frame.getZ();</span>

<span class="fc" id="L3130">        final var diffX = currentX - initX;</span>
<span class="fc" id="L3131">        final var diffY = currentY - initY;</span>
<span class="fc" id="L3132">        final var diffZ = currentZ - initZ;</span>

<span class="fc" id="L3134">        currentPositionDrift.setCoordinates(diffX, diffY, diffZ);</span>

<span class="fc" id="L3136">        currentPositionDriftMeters = currentPositionDrift.getNorm();</span>
<span class="fc" id="L3137">    }</span>

    /**
     * Computes current velocity drift.
     */
    protected void computeCurrentVelocityDrift() {
<span class="fc" id="L3143">        final var initVx = referenceFrame.getVx();</span>
<span class="fc" id="L3144">        final var initVy = referenceFrame.getVy();</span>
<span class="fc" id="L3145">        final var initVz = referenceFrame.getVz();</span>

<span class="fc" id="L3147">        final var currentVx = frame.getVx();</span>
<span class="fc" id="L3148">        final var currentVy = frame.getVy();</span>
<span class="fc" id="L3149">        final var currentVz = frame.getVz();</span>

<span class="fc" id="L3151">        final var diffVx = currentVx - initVx;</span>
<span class="fc" id="L3152">        final var diffVy = currentVy - initVy;</span>
<span class="fc" id="L3153">        final var diffVz = currentVz - initVz;</span>

<span class="fc" id="L3155">        currentVelocityDrift.setCoordinates(diffVx, diffVy, diffVz);</span>

<span class="fc" id="L3157">        currentVelocityDriftMetersPerSecond = currentVelocityDrift.getNorm();</span>
<span class="fc" id="L3158">    }</span>

    /**
     * Computes current orientation drift.
     *
     * @throws AlgebraException               if there are numerical instabilities.
     * @throws InvalidRotationMatrixException if rotation cannot be accurately
     *                                        estimated.
     */
    protected void computeCurrentOrientationDrift() throws AlgebraException, InvalidRotationMatrixException {
<span class="fc bfc" id="L3168" title="All 2 branches covered.">        if (currentC == null) {</span>
<span class="fc" id="L3169">            currentC = new Matrix(Rotation3D.INHOM_COORDS, Rotation3D.INHOM_COORDS);</span>
        }
<span class="fc" id="L3171">        frame.getCoordinateTransformationMatrix(currentC);</span>

<span class="fc" id="L3173">        q.fromMatrix(currentC);</span>
<span class="fc" id="L3174">        q.combine(invRefQ);</span>

<span class="fc" id="L3176">        currentOrientationDriftRadians = q.getRotationAngle();</span>
<span class="fc" id="L3177">    }</span>

    /**
     * Converts the provided time instance to seconds.
     *
     * @param time instance to be converted.
     * @return conversion in seconds.
     */
    private static double convertTime(final Time time) {
<span class="fc" id="L3186">        return TimeConverter.convert(time.getValue().doubleValue(), time.getUnit(), TimeUnit.SECOND);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>